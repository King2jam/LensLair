<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Monster Transform Game</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<!-- TFJS + Teachable Machine (locked to broadly compatible versions) -->
<script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@3.21.0/dist/tf.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@teachablemachine/image@0.8.4/dist/teachablemachine-image.min.js"></script>
<style>
  :root{
    --bg:#111418; --panel:#1a1f24; --muted:#222831; --ink:#e8f0ff;
    --accent:#5aa9e6; --accent2:#7fc8a9; --warn:#ffb84d; --danger:#e85959;
    --ok:#61d095; --chip:#2a323b;
  }
  *{box-sizing:border-box}
  body{
    margin:0; font-family: ui-sans-serif,system-ui,Segoe UI,Roboto,Helvetica,Arial;
    background:var(--bg); color:var(--ink);
  }
  header{padding:18px 16px 0; text-align:center}
  header h1{margin:0 0 8px; font-size:clamp(22px,3.5vw,34px)}
  header p{margin:0 0 14px; opacity:.8}

  .wrap{max-width:1200px; margin:0 auto; padding:16px; display:grid; gap:16px;
        grid-template-columns: 1.2fr .9fr;}
  @media (max-width: 980px){ .wrap{grid-template-columns: 1fr} }

  .card{background:var(--panel); border:1px solid #20262d; border-radius:14px; overflow:hidden}
  .card .head{padding:10px 12px; background:var(--muted); border-bottom:1px solid #20262d; font-weight:700}
  .pad{padding:12px}
  .row{display:flex; gap:10px; align-items:center; flex-wrap:wrap}
  .grow{flex:1}
  .btn{
    background:var(--accent); border:none; color:#071018; padding:10px 14px; border-radius:10px;
    font-weight:700; cursor:pointer;
  }
  .btn.secondary{ background:#2d3640; color:#d6e7ff }
  .btn.warn{ background:var(--warn); color:#1b1302 }
  .btn.danger{ background:var(--danger) }
  .btn.ok{ background:var(--ok); color:#02140a }
  .btn:disabled{opacity:.5; cursor:not-allowed}

  .camShell{position:relative; background:#000; border-radius:12px; overflow:hidden; border:2px solid #39424c}
  video, canvas{width:100%; height:auto; display:block; background:#000}
  .devicePick{width:100%; background:#1f2730; color:var(--ink); border:1px solid #303a45; border-radius:10px; padding:10px}

  .log{white-space:pre-wrap; background:#0f0f0f; border:1px solid #2a2a2a; color:#c6d1e5; padding:8px; border-radius:10px; min-height:60px; text-align:left}
  .chip{display:inline-block; background:var(--chip); padding:4px 8px; border-radius:999px; font-size:12px; opacity:.9}

  .collection{display:grid; grid-template-columns:1fr; gap:10px}
  .kpi{display:flex; gap:8px; align-items:center; padding:8px 10px}
  .kpi .pill{background:#212a33; border:1px solid #2e3743; border-radius:999px; padding:6px 10px}

  .monsterGrid{display:grid; grid-template-columns:repeat(2,1fr); gap:10px}
  @media (max-width:540px){ .monsterGrid{grid-template-columns:1fr} }

  .mCard{background:#13181d; border:1px solid #29313a; border-radius:12px; overflow:hidden}
  .mCard img{width:100%; display:block; aspect-ratio:16/10; object-fit:cover; background:#0b0b0b}
  .mBody{padding:10px}
  .mTop{display:flex; align-items:center; justify-content:space-between; gap:10px}
  .mName{font-weight:800; letter-spacing:.3px}
  .rar{font-size:12px; padding:2px 8px; border-radius:999px; border:1px solid #2d3440}
  .rar.common{background:#1f2630; color:#b7c0d4}
  .rar.uncommon{background:#173126; color:#a8e6c3; border-color:#285a43}
  .rar.rare{background:#2a1837; color:#e7befc; border-color:#6741a0}
  .stats{display:grid; grid-template-columns:repeat(2,1fr); gap:6px; margin-top:8px}
  .stat{background:#101419; border:1px solid #222a33; padding:6px 8px; border-radius:8px; font-size:13px}
  .actions{display:flex; gap:8px; margin-top:8px}
  .teamRow{display:grid; grid-template-columns:repeat(3,1fr); gap:10px}
  .slot{min-height:84px; border:1px dashed #3a3a3a; border-radius:12px; display:grid; place-items:center; background:#0f1419}
  .slot .hint{opacity:.7; font-size:12px}

  .modalMask{position:fixed; inset:0; background:rgba(0,0,0,.6); display:none; place-items:center; z-index:50}
  .modal{background:var(--panel); border:1px solid #2c363f; border-radius:12px; max-width:520px; width:92%; padding:12px}
  .modal h3{margin:8px 0 6px}
</style>
</head>
<body>
  <header>
    <h1>Monster Transform Game</h1>
    <p>Capture a real creature and see its monster form. Works on desktop, Android, and iPhone (HTTPS).</p>
  </header>

  <main class="wrap">
    <!-- LEFT: Capture / Upload -->
    <section class="card">
      <div class="head">Capture</div>
      <div class="pad">
        <div id="status" class="chip">Initializing‚Ä¶</div>
        <div class="camShell" style="margin-top:10px;">
          <video id="webcam" playsinline muted></video>
          <canvas id="frame" hidden></canvas>
        </div>

        <div class="row" style="margin-top:10px;">
          <button id="btnEnable" class="btn">üé• Enable Camera</button>
          <button id="btnCapture" class="btn secondary" disabled>üì∏ Capture Photo</button>
          <label class="btn secondary">
            ‚¨ÜÔ∏è Upload Photo
            <input id="uploader" type="file" accept="image/*" hidden>
          </label>
          <select id="deviceSel" class="devicePick"></select>
        </div>

        <div id="log" class="log" style="margin-top:10px;">Log: ready.</div>
      </div>
    </section>

    <!-- RIGHT: Collection / Team -->
    <section class="card">
      <div class="head">Your Collection</div>
      <div class="pad collection">
        <div class="kpi">
          <div class="pill">Upgrade Dust: <span id="dust">0</span></div>
          <div class="pill">Team: <span id="teamCount">0</span>/3</div>
          <div class="pill">Inventory: <span id="invCount">0</span>/20</div>
        </div>

        <h3>Team</h3>
        <div id="team" class="teamRow"></div>

        <h3 style="margin-top:10px;">Inventory</h3>
        <div id="inventory" class="monsterGrid"></div>

        <div class="row" style="margin-top:12px;">
          <button id="btnWild" class="btn">‚öîÔ∏è Wild Battle</button>
          <button id="btnBoss" class="btn warn">üëπ Boss Hunt</button>
          <span class="chip">Battles auto-resolve for now.</span>
        </div>
      </div>
    </section>
  </main>

  <!-- Force-breakdown modal -->
  <div id="modalMask" class="modalMask">
    <div class="modal">
      <h3>Inventory Full</h3>
      <p>You can store up to 20 monsters. Pick one to <strong>break down</strong> into shards to make room.</p>
      <div id="modalList" class="monsterGrid" style="max-height:50vh; overflow:auto;"></div>
      <div class="row" style="margin-top:10px; justify-content:flex-end;">
        <button id="modalCancel" class="btn secondary">Cancel</button>
      </div>
    </div>
  </div>

<script>
/* -----------------------------
   CONFIG / CONSTANTS
------------------------------*/
const MODEL_URL = "model_real/"; // model.json, metadata.json, weights.bin in this folder

// Optional: when you add a second model (e.g., bird) you can switch by changing this:
// const MODEL_URL = "models/bird/";

// Map model className -> digital artwork (in /digital_images/)
const DIGITAL_ART = {
  ladybug: "digital_images/ladybug.jpeg",
  squirrel:"digital_images/squirrel.jpeg",
  dog:     "digital_images/dog.jpeg",
  cat:     "digital_images/cat.jpeg",
  spider:  "digital_images/spider.jpeg",
  fly:     "digital_images/fly.jpeg",
  // add more here as you create art: "bird":"digital_images/bird.jpeg"
};

// Base stat templates by archetype (then adjusted by rarity + small randomness)
const ARCHETYPES = {
  // {hp, atk, def, spd, crit, element, class}
  ladybug: { hp:90,  atk:40, def:90, spd:35, crit:8,  element:"Light",  class:"Guardian" },
  squirrel:{ hp:70,  atk:55, def:60, spd:90, crit:16, element:"Nature", class:"Skirmisher"},
  dog:     { hp:85,  atk:60, def:75, spd:55, crit:10, element:"Earth",  class:"Guardian" },
  cat:     { hp:65,  atk:88, def:45, spd:92, crit:18, element:"Shadow", class:"Assassin" },
  spider:  { hp:72,  atk:55, def:68, spd:60, crit:12, element:"Poison", class:"Trapper" },
  fly:     { hp:50,  atk:40, def:35, spd:99, crit:14, element:"Air",    class:"Scout"  },
  // you can add others matching your model classes later
};

// Battle pool (wild + bosses). Bosses are very hard.
const WILD_POOL = [
  { name:"wild-cat",     base:{hp:70, atk:60, def:45, spd:70, crit:10}, element:"Shadow", class:"Skirmisher" },
  { name:"wild-dog",     base:{hp:85, atk:60, def:70, spd:55, crit: 9}, element:"Earth",  class:"Guardian"  },
  { name:"wild-ladybug", base:{hp:90, atk:40, def:90, spd:35, crit: 8}, element:"Light",  class:"Guardian"  },
  { name:"wild-spider",  base:{hp:75, atk:52, def:70, spd:62, crit:11}, element:"Poison", class:"Trapper"   },
  { name:"wild-squirrel",base:{hp:68, atk:58, def:60, spd:88, crit:15}, element:"Nature", class:"Skirmisher"},
  { name:"wild-fly",     base:{hp:50, atk:40, def:35, spd:95, crit:14}, element:"Air",    class:"Scout"     },
];
const BOSS_POOL = [
  { name:"Boss Tiger",      boss:true, base:{hp:320, atk:95,  def:80,  spd:85,  crit:16}, element:"Savanna", class:"Predator" },
  { name:"Boss Bear",       boss:true, base:{hp:420, atk:85,  def:110, spd:55,  crit:10}, element:"Earth",   class:"Juggernaut" },
  { name:"Boss Shark",      boss:true, base:{hp:360, atk:100, def:85,  spd:80,  crit:18}, element:"Water",   class:"Ravager" },
  { name:"Boss Lion",       boss:true, base:{hp:340, atk:98,  def:88,  spd:82,  crit:17}, element:"Savanna", class:"Predator" },
  { name:"Boss Snake",      boss:true, base:{hp:300, atk:88,  def:70,  spd:90,  crit:22}, element:"Poison",  class:"Ambusher" },
  { name:"Boss Alligator",  boss:true, base:{hp:380, atk:92,  def:105, spd:60,  crit:12}, element:"Water",   class:"Guardian" },
  { name:"Boss Pelican",    boss:true, base:{hp:360, atk:84,  def:80,  spd:88,  crit:14}, element:"Air",     class:"Overlord" }
];

// Rarity chances and multipliers
const RARITY_TABLE = [
  { key:"rare",      chance: 0.01, mult: 1.18 }, // ~1%, noticeably stronger
  { key:"uncommon",  chance: 0.15, mult: 1.12 }, // 15%
  { key:"common",    chance: 0.84, mult: 1.00 }, // rest
];

// inventory limits
const INV_LIMIT = 20;
const TEAM_LIMIT = 3;

/* -----------------------------
   STATE / STORAGE
------------------------------*/
const S = {
  monsters: [], // inventory
  team: [],     // array of monster ids
  dust: 0,
  nextId: 1,
};
const LS_KEY = "lenslair_save_v2";

function loadState(){
  try{
    const raw = localStorage.getItem(LS_KEY);
    if(raw){
      const obj = JSON.parse(raw);
      Object.assign(S, obj);
    }
  }catch(e){ console.warn("Load state error:", e); }
}
function saveState(){
  localStorage.setItem(LS_KEY, JSON.stringify(S));
}
function wipeState(){
  localStorage.removeItem(LS_KEY);
  location.reload();
}

/* -----------------------------
   UTIL
------------------------------*/
function log(msg){ const el = document.getElementById("log"); el.textContent = (el.textContent + "\n" + msg).slice(-2000); }
function byId(id){ return document.getElementById(id); }
function randInt(min,max){ return Math.floor(Math.random()*(max-min+1))+min; }
function pickRarity(){
  let r = Math.random();
  let acc = 0;
  for(const row of RARITY_TABLE){
    acc += row.chance;
    if(r <= acc) return row;
  }
  return RARITY_TABLE[RARITY_TABLE.length-1];
}
function statRoll(base, mult){
  // slight randomization around the multiplier (¬±4%)
  const jitter = 1 + (Math.random()*0.08 - 0.04);
  return Math.max(1, Math.round(base * mult * jitter));
}
function imgOrPlaceholder(name){
  const src = DIGITAL_ART[name?.toLowerCase()];
  return src || "https://dummyimage.com/640x360/0a0a0a/ffffff&text=Monster";
}

/* -----------------------------
   CAMERA / MODEL
------------------------------*/
let model = null, metadata = null;
let stream = null;
const video = byId("webcam");
const canvas = byId("frame");
const deviceSel = byId("deviceSel");
const statusChip = byId("status");

async function loadModel(){
  try{
    model = await tmImage.load(MODEL_URL + "model.json", MODEL_URL + "metadata.json");
    metadata = model?.getTotalClasses?.() ?? null;
    log("‚úÖ Model loaded");
    statusChip.textContent = "Model ready.";
  }catch(e){
    log("‚ö†Ô∏è Model load failed ‚Äî capturing will still create a monster via fallback. " + e.message);
    statusChip.textContent = "Model unavailable (fallback active)";
  }
}

// enumerate devices for camera selection (helps iOS/Android)
async function refreshDevices(){
  try{
    const list = await navigator.mediaDevices.enumerateDevices();
    const cams = list.filter(d => d.kind === "videoinput");
    deviceSel.innerHTML = "";
    cams.forEach((d, i)=>{
      const o = document.createElement("option");
      o.value = d.deviceId;
      o.textContent = d.label || `Camera ${i+1}`;
      deviceSel.appendChild(o);
    });
    if(cams.length===0){
      const o = document.createElement("option");
      o.value = "";
      o.textContent = "No camera found";
      deviceSel.appendChild(o);
    }
  }catch(e){ log("enumerateDevices error: " + e.message); }
}

async function startCamera(deviceId){
  if(stream){ stream.getTracks().forEach(t=>t.stop()); stream=null; }
  const constraints = deviceId
    ? { video: { deviceId: { exact: deviceId } } }
    : { video: { facingMode: { ideal:"environment" } } };

  try{
    stream = await navigator.mediaDevices.getUserMedia(constraints);
    video.srcObject = stream;
    await video.play();
    statusChip.textContent = "Camera ready.";
    byId("btnCapture").disabled = false;
    log("üé• Camera started");
  }catch(e){
    log("Camera error: " + e.name + " ‚Äî " + e.message);
    statusChip.textContent = "Camera failed. Try a different device above or use Upload.";
    byId("btnCapture").disabled = true;
  }
}

function drawCurrentFrame(){
  const w = video.videoWidth || 640, h = video.videoHeight || 480;
  canvas.width = w; canvas.height = h;
  const ctx = canvas.getContext("2d");
  ctx.drawImage(video, 0, 0, w, h);
  return canvas;
}

/* -----------------------------
   MONSTER CREATION
------------------------------*/
function createFromClassName(cls){
  // base from archetype (or generic if unknown)
  const key = (cls||"").toLowerCase();
  const base = ARCHETYPES[key] || { hp:70, atk:60, def:60, spd:60, crit:10, element:"Neutral", class:"Adventurer" };
  const art = imgOrPlaceholder(key);

  const rarityRow = pickRarity(); // rare/uncommon/common
  const mult = rarityRow.mult;

  const monster = {
    id: S.nextId++,
    name: key || "unknown",
    element: base.element,
    class: base.class,
    rarity: rarityRow.key,
    art,
    // rolled stats
    hp:  statRoll(base.hp,  mult),
    atk: statRoll(base.atk, mult),
    def: statRoll(base.def, mult),
    spd: statRoll(base.spd, mult),
    crit:statRoll(base.crit,mult),
    lvl:1, xp:0,
    ts: Date.now()
  };
  return monster;
}

async function classifyCanvas(canv){
  if(!model){
    log("Model not loaded, using fallback class.");
    return null;
  }
  const preds = await model.predict(canv);
  preds.sort((a,b)=>b.probability-a.probability);
  const top = preds[0];
  if(!top || top.probability < 0.40){
    log("Low confidence ("+(top?.probability?.toFixed(2)??"n/a")+") ‚Äî using fallback.");
    return null;
  }
  return (top.className||"").toLowerCase();
}

async function pipelineFromCanvas(canv){
  // classify ‚Üí build monster ‚Üí enforce capacity ‚Üí render/save
  let cls = null;
  try{ cls = await classifyCanvas(canv); }
  catch(e){ log("Prediction failed: " + e.message); }

  const monster = createFromClassName(cls);
  await ensureCapacityOrBreakdown(); // may open modal
  S.monsters.push(monster);
  saveState();
  renderAll();
  log(`‚ú® Created ${monster.rarity.toUpperCase()} ${monster.name.toUpperCase()} (HP:${monster.hp} ATK:${monster.atk})`);
}

/* -----------------------------
   INVENTORY CAP / BREAKDOWN
------------------------------*/
const mask = byId("modalMask"), modalList = byId("modalList"), modalCancel = byId("modalCancel");
modalCancel.addEventListener("click", ()=> mask.style.display="none");

async function ensureCapacityOrBreakdown(){
  if(S.monsters.length < INV_LIMIT) return;
  // Force user to break one down
  return new Promise(resolve=>{
    modalList.innerHTML = "";
    S.monsters.forEach(m=>{
      const card = miniCard(m, [
        {label:"Break for Shards", cls:"danger", onClick:()=>{
          const shards = m.rarity==="rare" ? 40 : m.rarity==="uncommon" ? 18 : 8;
          S.dust += shards;
          // also drop from team if present
          S.team = S.team.filter(id=>id!==m.id);
          S.monsters = S.monsters.filter(x=>x.id!==m.id);
          saveState(); renderAll();
          resolve();
          mask.style.display="none";
        }}
      ]);
      modalList.appendChild(card);
    });
    mask.style.display="grid";
  });
}

/* -----------------------------
   RENDERING
------------------------------*/
function monsterCard(mon, ctx="inventory"){
  const el = document.createElement("div");
  el.className = "mCard";
  el.innerHTML = `
    <img src="${mon.art}" alt="${mon.name}">
    <div class="mBody">
      <div class="mTop">
        <div class="mName">${mon.name.toUpperCase()} ‚Ä¢ <span style="opacity:.8">${mon.element}</span></div>
        <div class="rar ${mon.rarity}">${mon.rarity}</div>
      </div>
      <div class="stats">
        <div class="stat">HP: <b>${mon.hp}</b></div>
        <div class="stat">ATK: <b>${mon.atk}</b></div>
        <div class="stat">DEF: <b>${mon.def}</b></div>
        <div class="stat">SPD: <b>${mon.spd}</b></div>
        <div class="stat">CRIT: <b>${mon.crit}%</b></div>
        <div class="stat">LVL: <b>${mon.lvl}</b></div>
      </div>
      <div class="actions"></div>
    </div>`;
  const acts = el.querySelector(".actions");

  if(ctx==="inventory"){
    // add to team (if there is space)
    const b1 = button("Add to Team", "ok", ()=>{
      if(S.team.includes(mon.id)) return;
      if(S.team.length >= TEAM_LIMIT){ alert("Team is full (3). Remove one first."); return; }
      S.team.push(mon.id); saveState(); renderAll();
    });
    const b2 = button("Breakdown", "danger", ()=>{
      const shards = mon.rarity==="rare" ? 40 : mon.rarity==="uncommon" ? 18 : 8;
      if(!confirm(`Break ${mon.name.toUpperCase()} for ${shards} shards?`)) return;
      S.dust += shards;
      S.monsters = S.monsters.filter(x=>x.id!==mon.id);
      S.team = S.team.filter(id=>id!==mon.id);
      saveState(); renderAll();
    });
    acts.append(b1,b2);
  }else if(ctx==="team"){
    const b1 = button("Remove", "secondary", ()=>{
      S.team = S.team.filter(id=>id!==mon.id);
      saveState(); renderAll();
    });
    acts.append(b1);
  }
  return el;
}
function miniCard(mon, actions=[]){
  const el = document.createElement("div");
  el.className = "mCard";
  el.innerHTML = `
    <img src="${mon.art}" alt="${mon.name}">
    <div class="mBody">
      <div class="mTop"><div class="mName">${mon.name.toUpperCase()}</div><div class="rar ${mon.rarity}">${mon.rarity}</div></div>
      <div class="stats">
        <div class="stat">HP:${mon.hp}</div>
        <div class="stat">ATK:${mon.atk}</div>
      </div>
      <div class="actions"></div>
    </div>`;
  const acts = el.querySelector(".actions");
  actions.forEach(a=>{
    const b = button(a.label, a.cls, a.onClick); acts.appendChild(b);
  });
  return el;
}
function button(txt, cls, onClick){
  const b = document.createElement("button");
  b.className = "btn " + (cls||"");
  b.textContent = txt;
  b.addEventListener("click", onClick);
  return b;
}

function renderAll(){
  byId("dust").textContent = S.dust;
  byId("invCount").textContent = S.monsters.length;
  byId("teamCount").textContent = S.team.length;

  // team view
  const teamEl = byId("team");
  teamEl.innerHTML = "";
  for(let i=0;i<TEAM_LIMIT;i++){
    const id = S.team[i];
    if(id){
      const mon = S.monsters.find(x=>x.id===id);
      if(mon) teamEl.appendChild(monsterCard(mon,"team"));
      else{
        // clean up dangling ids
        S.team = S.team.filter(tid => S.monsters.some(m=>m.id===tid));
        saveState();
      }
    }else{
      const slot = document.createElement("div");
      slot.className = "slot";
      slot.innerHTML = `<div class="hint">Empty slot</div>`;
      teamEl.appendChild(slot);
    }
  }
  // inventory
  const invEl = byId("inventory");
  invEl.innerHTML = "";
  S.monsters
    .filter(m => !S.team.includes(m.id))
    .sort((a,b)=>b.ts-a.ts)
    .forEach(m=> invEl.appendChild(monsterCard(m,"inventory")));
}

/* -----------------------------
   BATTLES (auto-resolve)
------------------------------*/
function basicDuel(a, b){
  // very quick auto resolution: each turn, damage = atk * (100/(100+def)) * variance
  function dmg(att, def){
    const raw = att * (100/(100 + def));
    const variance = 0.85 + Math.random()*0.3;
    let crit = 1;
    if(Math.random() < (att.crit||10)/100) crit = 1.5;
    return Math.max(1, Math.round(raw * variance * crit));
  }
  let ahp=a.hp, bhp=b.hp;
  let turns=0;
  while(ahp>0 && bhp>0 && turns<200){
    // initiative: higher spd first; tie random
    const first = (a.spd===b.spd) ? (Math.random()<0.5?a:b) : ((a.spd>b.spd)?a:b);
    const second = (first===a)?b:a;
    if(first===a){ bhp -= dmg(a,b); if(bhp<=0) break; ahp -= dmg(b,a); }
    else        { ahp -= dmg(b,a); if(ahp<=0) break; bhp -= dmg(a,b); }
    turns++;
  }
  return ahp>0 ? "player" : "enemy";
}

function pickWild(boss=false){
  const src = boss ? BOSS_POOL : WILD_POOL;
  const x = src[Math.floor(Math.random()*src.length)];
  return {
    name: x.name,
    element: x.element,
    class: x.class,
    rarity: boss ? "boss" : "wild",
    art: imgOrPlaceholder(x.name.includes("wild-") ? x.name.split("wild-")[1] : x.name),
    ...x.base
  };
}

function runBattle(boss=false){
  if(S.team.length===0){ alert("Add at least one monster to your team first."); return; }

  // build combined team power (sum of top 3)
  const teamMons = S.team.map(id => S.monsters.find(m=>m.id===id)).filter(Boolean);
  const teamFighter = {
    name:"Your Team",
    hp: teamMons.reduce((s,m)=>s+m.hp,0),
    atk:Math.round(teamMons.reduce((s,m)=>s+m.atk,0)/teamMons.length),
    def:Math.round(teamMons.reduce((s,m)=>s+m.def,0)/teamMons.length),
    spd:Math.round(teamMons.reduce((s,m)=>s+m.spd,0)/teamMons.length),
    crit:Math.round(teamMons.reduce((s,m)=>s+m.crit,0)/teamMons.length),
  };

  // enemy
  const enemy = pickWild(boss);

  const who = basicDuel(teamFighter, enemy);
  if(who==="player"){
    const reward = boss ? 120 : 25 + Math.round(Math.random()*20);
    S.dust += reward;
    saveState(); renderAll();
    alert(`Victory!\nYou defeated ${enemy.name} and gained ${reward} dust.`);
  }else{
    alert(`Defeat‚Ä¶ ${enemy.name} was too strong this time.`);
  }
}

/* -----------------------------
   EVENT WIRING
------------------------------*/
byId("btnEnable").addEventListener("click", async ()=>{
  if(location.protocol!=="https:"){
    alert("On mobile Safari/Chrome, camera requires HTTPS (GitHub Pages is fine). Upload still works.");
  }
  await refreshDevices();
  const id = deviceSel.value || undefined;
  await startCamera(id);
});

deviceSel.addEventListener("change", async (e)=>{ await startCamera(e.target.value); });

byId("btnCapture").addEventListener("click", async ()=>{
  try{
    const canv = drawCurrentFrame();
    await pipelineFromCanvas(canv);
  }catch(e){
    log("Capture flow error: " + e.message);
  }
});

byId("uploader").addEventListener("change", async (e)=>{
  const file = e.target.files?.[0];
  if(!file) return;
  try{
    const img = new Image();
    img.onload = async ()=>{
      canvas.width = img.naturalWidth; canvas.height = img.naturalHeight;
      const ctx = canvas.getContext("2d");
      ctx.drawImage(img, 0, 0);
      await pipelineFromCanvas(canvas);
    };
    img.src = URL.createObjectURL(file);
  }catch(err){
    log("Upload flow error: " + err.message);
  }finally{
    e.target.value = "";
  }
});

byId("btnWild").addEventListener("click", ()=> runBattle(false));
byId("btnBoss").addEventListener("click", ()=> runBattle(true));

/* -----------------------------
   BOOT
------------------------------*/
(async function boot(){
  loadState();
  renderAll();
  statusChip.textContent = "Loading model‚Ä¶";
  await loadModel();
  await refreshDevices();
  log("Tip: If camera fails on mobile, pick a different device from the dropdown, or use Upload.");
})();
</script>
</body>
</html>
