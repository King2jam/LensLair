<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Monster Transform — PvPvE Beta</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0" />

<!--
FOLDERS REQUIRED (in your GitHub repo root):

/model_real/
  - model.json
  - metadata.json
  - weights.bin
/digital_images/
  - dog.jpeg
  - cat.jpeg
  - squirrel.jpeg
  - spider.jpeg
  - fly.jpeg
  - ladybug.jpeg
  - boss_dragon.png           (placeholder)
  - boss_kraken.png           (placeholder)
  - miniboss_wolf.png         (placeholder)
  - miniboss_golem.png        (placeholder)

IMPORTANT (Mobile camera):
- Serve over HTTPS (GitHub Pages is HTTPS by default).
- iOS Safari: uses rear camera with {facingMode: "environment"} but may fall back.
- If camera fails, you can still Upload Photo (bottom-right).

HOW TO ADD NEW MONSTERS:
1) Put image into /digital_images/ as .png or .jpeg
2) Add a Teachable Machine class with EXACT SAME lowercase name (e.g., "bear")
3) Add an entry into MONSTER_DEX below with element + class type and base stats.
-->

<style>
  :root{
    --bg:#111; --panel:#1b1b1b; --soft:#222; --accent:#77e; --good:#4caf50; --warn:#ffc107; --bad:#e53935;
    --rare:#72e5ff; --epic:#b388ff; --legend:#ffcc80; --mythic:#ff6ec7; --ultra:#ffd700;
  }
  html,body{margin:0;padding:0;background:var(--bg);color:#eee;font-family:Inter,system-ui,Arial;}
  header{padding:14px 12px;text-align:center;background:linear-gradient(90deg,#222,#191919);position:sticky;top:0;z-index:5}
  .title{font-weight:800;letter-spacing:.5px}
  .sub{opacity:.8;font-size:.95rem}
  .wrap{max-width:1100px;margin:0 auto;padding:12px}
  .grid{display:grid;grid-template-columns:1fr;gap:12px}
  @media(min-width:900px){ .grid{grid-template-columns: 1.1fr .9fr} }

  /* Camera panel */
  .card{background:var(--panel);border:1px solid #2a2a2a;border-radius:16px;padding:12px;position:relative;overflow:hidden}
  .section-title{font-weight:700;margin:4px 0 8px}
  video,canvas{width:100%;max-height:360px;background:#000;border-radius:12px}
  .controls{display:flex;gap:8px;flex-wrap:wrap;margin-top:8px}
  button{background:#2b2b2b;border:1px solid #3a3a3a;color:#fff;padding:10px 14px;border-radius:12px;cursor:pointer}
  button:hover{filter:brightness(1.1)}
  .primary{background:linear-gradient(90deg,#5561ff,#a25bff);border:none}
  .danger{background:linear-gradient(90deg,#a33,#d33);border:none}
  .ghost{background:#262626}

  /* Tabs */
  .tabs{display:flex;gap:8px;margin:8px 0 4px;flex-wrap:wrap}
  .tab{padding:8px 12px;border-radius:999px;background:#222;border:1px solid #2e2e2e;cursor:pointer}
  .tab.active{background:#333;border-color:#555}

  /* Inventory & Team */
  .row{display:flex;gap:10px;flex-wrap:wrap}
  .pill{padding:4px 10px;border-radius:999px;background:#1f1f1f;border:1px solid #2c2c2c;font-size:.85rem}
  .slot{background:#181818;border:1px dashed #3a3a3a;border-radius:12px;min-width:120px;min-height:120px;display:flex;flex-direction:column;align-items:center;justify-content:center;gap:6px;padding:10px;position:relative}
  .slot img{max-width:96px;max-height:96px;object-fit:contain}
  .slot .name{font-weight:700;font-size:.9rem}
  .slot .rar{font-size:.75rem;opacity:.85}

  /* Rarity glow around card borders */
  .glow-Common{box-shadow:0 0 0 0 transparent}
  .glow-Uncommon{box-shadow:0 0 8px 0 rgba(114,229,255,.25)}
  .glow-Rare{box-shadow:0 0 10px 1px rgba(179,136,255,.35)}
  .glow-Epic{box-shadow:0 0 12px 2px rgba(255,204,128,.40)}
  .glow-Legendary{box-shadow:0 0 12px 2px rgba(255,110,199,.45)}
  .glow-Mythic{box-shadow:0 0 14px 3px rgba(255,215,0,.55)}

  /* Bars */
  .bar{height:10px;background:#333;border-radius:6px;overflow:hidden}
  .bar>span{display:block;height:100%}
  .hp{background:var(--bad)}
  .sta{background:var(--good)}

  /* Monster Card */
  .monster-card{background:var(--soft);border:1px solid #2e2e2e;border-radius:16px;padding:12px;margin-top:10px;position:relative;overflow:hidden}
  .monster-head{display:flex;gap:10px;align-items:center}
  .monster-img{width:120px;height:120px;background:#0b0b0b;border-radius:14px;display:flex;align-items:center;justify-content:center;overflow:hidden}
  .monster-img img{max-width:100%;max-height:100%;object-fit:contain}
  .statgrid{display:grid;grid-template-columns:repeat(2,1fr);gap:6px;margin-top:10px}
  .stat{background:#1f1f1f;border:1px solid #2b2b2b;border-radius:10px;padding:8px;font-size:.9rem}
  .badge{padding:3px 8px;border-radius:999px;font-size:.75rem;border:1px solid #333;background:#1d1d1d}
  .rarC{background:#1a2230;border-color:#294b8a}
  .rarU{background:#112a2e;border-color:#16515a}
  .rarR{background:#1d1530;border-color:#3f2a7a}
  .rarE{background:#2b1e09;border-color:#7a4c1b}
  .rarL{background:#321428;border-color:#7a2c5d}
  .rarM{background:#332900;border-color:#7a6a1b}

  /* Toast/overlay & fly-to-inventory animation */
  .toast{position:fixed;left:50%;transform:translateX(-50%);bottom:22px;background:#222;border:1px solid #444;padding:10px 14px;border-radius:12px;z-index:50}
  .loot-fly{position:fixed;pointer-events:none;transition:transform .9s cubic-bezier(.22,1,.36,1), opacity .9s; z-index:60}
  .silhouette{filter:brightness(.0) saturate(0);opacity:.95}

  /* Cinematic modal */
  .modal{position:fixed;inset:0;background:rgba(0,0,0,.75);display:none;align-items:center;justify-content:center;z-index:70}
  .modal.show{display:flex}
  .modal-card{background:#141414;border:1px solid #2a2a2a;border-radius:16px;padding:16px;max-width:640px;width:92%;text-align:center}
</style>

<!-- TFJS + Teachable Machine (use these pinned versions for stability) -->
<script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@3.21.0/dist/tf.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@teachablemachine/image@0.8.4/dist/teachablemachine-image.min.js"></script>
</head>
<body>
<header>
  <div class="title">Monster Transform — PvPvE Beta</div>
  <div class="sub">Capture real animals → transform into digital monsters • Build team • Battle wilds & bosses • Loot & Upgrades</div>
</header>

<div class="wrap grid">

  <!-- LEFT: Camera + Capture + Result -->
  <section class="card" id="cameraCard">
    <div class="section-title">📷 Capture</div>
    <video id="webcam" autoplay playsinline muted></video>
    <canvas id="frameCanvas" style="display:none;"></canvas>
    <div class="controls">
      <button class="primary" id="btnStartCam">Start Camera</button>
      <button id="btnCapture">Capture Photo</button>
      <input type="file" id="fileInput" accept="image/*" capture="environment" style="display:none" />
      <button class="ghost" id="btnUpload">Upload Photo</button>
      <button class="danger" id="btnStopCam">Stop Camera</button>
    </div>
    <div id="camError" class="pill" style="display:none;background:#2d1919;border-color:#5a2b2b;color:#ffb3b3;margin-top:8px"></div>

    <div id="resultZone"></div>
  </section>

  <!-- RIGHT: Tabs, Inventory, Team, Battles -->
  <section class="card">
    <div class="tabs">
      <div class="tab active" data-tab="inventory">Inventory</div>
      <div class="tab" data-tab="team">Team</div>
      <div class="tab" data-tab="battle">Battle</div>
      <div class="tab" data-tab="upgrades">Upgrades</div>
      <div class="tab" data-tab="loot">Loot</div>
      <div class="tab" data-tab="mythic">Mythics</div>
    </div>

    <div id="panel-inventory">
      <div class="row">
        <span class="pill">Monsters: <span id="invCount">0</span></span>
        <span class="pill">Unique Mythics: <span id="mythCount">0</span></span>
        <span class="pill">Total Kills: <span id="killCount">0</span></span>
      </div>
      <div id="inventoryList" class="row" style="margin-top:8px"></div>
    </div>

    <div id="panel-team" style="display:none">
      <div class="row" style="margin-bottom:6px">
        <span class="pill">Team size: 3</span>
        <button id="btnClearTeam" class="ghost">Clear Team</button>
      </div>
      <div id="teamSlots" class="row"></div>
    </div>

    <div id="panel-battle" style="display:none">
      <div class="row" style="margin-bottom:6px">
        <button class="primary" id="btnWild">Find Wild Fight</button>
        <button id="btnMiniBoss">Mini-Boss</button>
        <button id="btnBoss">Boss</button>
      </div>
      <div id="battleArea"></div>
    </div>

    <div id="panel-upgrades" style="display:none">
      <div class="row" style="margin-bottom:6px;gap:8px">
        <span class="pill">Shards: <span id="shardCount">0</span></span>
        <span class="pill">Gold: <span id="goldCount">0</span></span>
        <span class="pill">Boss Mats: <span id="matCount">0</span></span>
      </div>
      <div id="upgradeArea"></div>
    </div>

    <div id="panel-loot" style="display:none">
      <div id="lootList" class="row"></div>
    </div>

    <div id="panel-mythic" style="display:none">
      <div id="mythicList" class="row"></div>
    </div>
  </section>
</div>

<!-- Cinematic Modal -->
<div class="modal" id="cinematic">
  <div class="modal-card">
    <h2 id="cinTitle">MYTHIC DISCOVERED!</h2>
    <div style="display:flex;gap:12px;align-items:center;justify-content:center;margin-top:10px">
      <div class="monster-img" style="width:160px;height:160px">
        <img id="cinImg" class="silhouette" alt="mythic" />
      </div>
      <div style="text-align:left;max-width:300px">
        <div id="cinText" style="opacity:.9;line-height:1.4"></div>
        <button id="cinClose" class="primary" style="margin-top:10px">Claim</button>
      </div>
    </div>
  </div>
</div>

<div id="toast" class="toast" style="display:none"></div>
<div id="flyLayer"></div>

<script>
/* =========================
   DATA & CONFIG
========================= */

// Model path
const MODEL_URL = "model_real/";

// Camera preferences
const CAM_CONSTRAINTS_PRIMARY   = { video: { facingMode: { ideal: "environment" } }, audio:false };
const CAM_CONSTRAINTS_FALLBACK  = { video: { facingMode: "user" }, audio:false };

// Duplicate-prevention cooldown (ms)
const CAPTURE_COOLDOWN_MS = 6000;

// Rarities & colors
const RARITY_ORDER = ["Common","Uncommon","Rare","Epic","Legendary","Mythic"];
const RARITY_COLOR = {
  Common:"#cfcfcf", Uncommon:"#72e5ff", Rare:"#b388ff",
  Epic:"#ffcc80", Legendary:"#ff6ec7", Mythic:"#ffd700"
};

// Base class templates (lightly themed by your spec)
const CLASS_TEMPLATES = {
  Tank:      { hp: 90, sta: 60, atk: 45, def: 70, spd: 35 },
  Guardian:  { hp: 80, sta: 60, atk: 50, def: 65, spd: 45 },
  Rogue:     { hp: 55, sta: 70, atk: 75, def: 35, spd: 80 },
  Assassin:  { hp: 50, sta: 65, atk: 85, def: 30, spd: 85 },
  Brawler:   { hp: 70, sta: 55, atk: 75, def: 55, spd: 55 },
  Trapper:   { hp: 65, sta: 60, atk: 60, def: 60, spd: 50 },
  Scout:     { hp: 45, sta: 75, atk: 40, def: 30, spd: 95 },
  Speedster: { hp: 60, sta: 65, atk: 55, def: 40, spd: 90 }
};

// Elements and lightweight advantage matrix (rock-paper-ish)
const ELEMENTS = ["Nature","Earth","Shadow","Light","Poison","Air","Water","Fire"];
const E_ADV = {
  Nature:["Earth","Water"],    // nature beats earth & water
  Earth:["Poison","Shadow"],   // etc.
  Shadow:["Light","Nature"],
  Light:["Shadow","Poison"],
  Poison:["Air","Nature"],
  Air:["Earth","Fire"],
  Water:["Fire","Earth"],
  Fire:["Nature","Shadow"]
};

// Your starting set mapped to TM class names:
const MONSTER_DEX = {
  dog:      { element:"Earth",  class:"Guardian", img:"digital_images/dog.jpeg" },
  cat:      { element:"Shadow", class:"Assassin", img:"digital_images/cat.jpeg" },
  squirrel: { element:"Nature", class:"Speedster",img:"digital_images/squirrel.jpeg" },
  spider:   { element:"Poison", class:"Trapper",  img:"digital_images/spider.jpeg" },
  fly:      { element:"Air",    class:"Scout",    img:"digital_images/fly.jpeg" },
  ladybug:  { element:"Light",  class:"Tank",     img:"digital_images/ladybug.jpeg" },
  // Unknown fallback
  "wild beast": { element:"Nature", class:"Brawler", img:"digital_images/ladybug.jpeg" }
};

// Boss & Mini-Boss art placeholders
const BOSS_ART = {
  dragon:"digital_images/boss_dragon.png",
  kraken:"digital_images/boss_kraken.png"
};
const MINIBOSS_ART = {
  wolf:"digital_images/miniboss_wolf.png",
  golem:"digital_images/miniboss_golem.png"
};

// Drop tables
const LOOT_TABLE = {
  wild: [
    { id:"gold_small", name:"Gold Pouch", qty:[10,30],  chance:0.40, rarity:"Common" },
    { id:"shard",      name:"Monster Shard", qty:[1,3], chance:0.20, rarity:"Uncommon" },
    { id:"item_minor", name:"Minor Upgrade Core", qty:[1,1], chance:0.05, rarity:"Rare" }
  ],
  miniboss: [
    { id:"gold_med",   name:"Gold Satchel", qty:[35,75], chance:0.60, rarity:"Uncommon" },
    { id:"shard",      name:"Monster Shard", qty:[2,4], chance:0.40, rarity:"Rare" },
    { id:"mat_wolfFang", name:"Dire Wolf Fang", qty:[1,1], chance:0.15, rarity:"Epic" },
    { id:"mythic_frag", name:"Mythic Fragment", qty:[1,1], chance:0.03, rarity:"Legendary" }, // mini-boss lower rate
  ],
  boss: [
    { id:"gold_big",   name:"Gold Chest", qty:[100,180], chance:0.90, rarity:"Rare" },
    { id:"shard",      name:"Monster Shard", qty:[3,6], chance:0.75, rarity:"Epic" },
    { id:"mat_dragonScale", name:"Ancient Dragon Scale", qty:[1,1], chance:0.35, rarity:"Legendary" },
    { id:"mat_krakenEye",   name:"Kraken’s Eye", qty:[1,1], chance:0.25, rarity:"Legendary" },
    { id:"mythic_core",     name:"Mythic Core",  qty:[1,1], chance:0.01, rarity:"Mythic" },     // 1%
    { id:"ultra_mythic_spark", name:"Ultra-Mythic Spark", qty:[1,1], chance:0.001, rarity:"Mythic" } // 0.1%
  ]
};

// Rarity rolls for captured monsters
// 1% Rare+, 0.5% Epic+, 0.2% Legendary, 0.05% Mythic; base Uncommon ~5%; rest Common
function rollRarity(){
  const r = Math.random();
  if (r < 0.0005) return "Mythic";      // 0.05%
  if (r < 0.0025) return "Legendary";   // 0.2%
  if (r < 0.0075) return "Epic";        // 0.5%
  if (r < 0.0175) return "Rare";        // 1%
  if (r < 0.0675) return "Uncommon";    // 5%
  return "Common";
}

// Power scaling by rarity (adds onto base class template)
const RARITY_MOD = { Common:0, Uncommon:5, Rare:10, Epic:20, Legendary:30, Mythic:45 };

/* =========================
   STATE & STORAGE
========================= */
let model=null, webcamStream=null, lastCaptureAt=0, lastHash=null;
const $ = s => document.querySelector(s);
const $$ = s => Array.from(document.querySelectorAll(s));

const state = {
  monsters: [],     // [{id,name,element,class,rarity,level,exp,stats,img,hash,createdAt}]
  team: [],         // ids
  loot: {},         // {id: qty}
  killCount: 0,
  mythicsSeen: {},  // {monsterName:true}
  items: {
    weapon:{lvl:0, rarity:"Common"},
    armor:{lvl:0, rarity:"Common"}
  }
};
loadState();

/* =========================
   UTILITIES
========================= */
function uid(){ return 'm'+Math.random().toString(36).slice(2)+Date.now().toString(36); }
function clamp(n,min,max){ return Math.max(min,Math.min(max,n)); }
function randInt(a,b){ return Math.floor(Math.random()*(b-a+1))+a; }
function rarityGlow(r){ return 'glow-'+r; }
function toast(msg){ const t=$("#toast"); t.textContent=msg; t.style.display='block'; setTimeout(()=>t.style.display='none',1600); }
function addLoot(id, qty=1){
  state.loot[id]=(state.loot[id]||0)+qty;
  saveState(); renderLoot();
}

function saveState(){ localStorage.setItem('mt_state', JSON.stringify(state)); }
function loadState(){
  const raw = localStorage.getItem('mt_state');
  if (raw){ try{ Object.assign(state, JSON.parse(raw)); }catch(e){} }
}

/* Tiny image hash to block duplicates */
async function imageHashFromCanvas(cv){
  const c=document.createElement('canvas'), w=32,h=32;
  c.width=w; c.height=h; const ctx=c.getContext('2d');
  ctx.drawImage(cv,0,0,w,h);
  const d=ctx.getImageData(0,0,w,h).data;
  // very simple rolling hash on grayscale
  let hval=0; for(let i=0;i<d.length;i+=4){ const g=(d[i]+d[i+1]+d[i+2])/3|0; hval=((hval<<5)-hval)+g; hval|=0; }
  return String(hval);
}

/* =========================
   CAMERA
========================= */
async function startCamera(){
  stopCamera();
  $("#camError").style.display="none";
  try{
    try{
      webcamStream = await navigator.mediaDevices.getUserMedia(CAM_CONSTRAINTS_PRIMARY);
    }catch(e){
      // Sometimes iOS needs exact constraint flip
      webcamStream = await navigator.mediaDevices.getUserMedia(CAM_CONSTRAINTS_FALLBACK);
    }
    $("#webcam").srcObject=webcamStream;
  }catch(err){
    $("#camError").style.display="block";
    $("#camError").textContent = `Camera error: ${err.name} — ${err.message}. You can still Upload Photo.`;
  }
}
function stopCamera(){
  if(!webcamStream) return;
  webcamStream.getTracks().forEach(t=>t.stop());
  webcamStream=null;
  $("#webcam").srcObject=null;
}

async function loadModel(){
  // quick presence check
  for(const f of ["model.json","metadata.json","weights.bin"]){
    try{ const r=await fetch(MODEL_URL+f,{cache:"no-store"}); if(!r.ok) console.warn("Missing/blocked:",f); }
    catch(e){ console.warn("Model fetch error:",f,e); }
  }
  model = await tmImage.load(MODEL_URL+"model.json", MODEL_URL+"metadata.json");
}

/* =========================
   MONSTER CREATION
========================= */
function computeStats(baseClass, rarity){
  const b = CLASS_TEMPLATES[baseClass] || CLASS_TEMPLATES.Brawler;
  const mod = RARITY_MOD[rarity]||0;
  // random +-5% noise
  const n = k => clamp(Math.round((b[k] + mod) * (0.95 + Math.random()*0.1)), 1, 999);
  return { hp:n('hp'), sta:n('sta'), atk:n('atk'), def:n('def'), spd:n('spd') };
}
function xpNeededFor(level){ return Math.round(30 * Math.pow(1.25, level-1)); }

/* Prevent dupes: hash + short cooldown */
function canCapture(hash){
  const now=Date.now();
  if(now-lastCaptureAt < CAPTURE_COOLDOWN_MS) return false;
  // block identical hash in last N monsters
  const recent = state.monsters.slice(-6);
  if(recent.some(m=>m.hash===hash)) return false;
  return true;
}

async function captureFromVideo(){
  if(!webcamStream){ toast("No webcam stream available."); return; }
  const v=$("#webcam");
  if(v.videoWidth===0){ toast("Camera not ready yet."); return; }
  const cv=$("#frameCanvas"), ctx=cv.getContext('2d');
  cv.width=v.videoWidth; cv.height=v.videoHeight;
  ctx.drawImage(v,0,0);
  await handleCapturedCanvas(cv,"camera");
}

async function captureFromFile(file){
  const img = new Image();
  img.onload = async ()=>{
    const cv=$("#frameCanvas"), ctx=cv.getContext('2d');
    cv.width=img.width; cv.height=img.height;
    ctx.drawImage(img,0,0);
    await handleCapturedCanvas(cv,"upload");
  };
  img.src = URL.createObjectURL(file);
}

async function handleCapturedCanvas(canvas, source){
  // hash for dupe protection
  const h = await imageHashFromCanvas(canvas);
  if(!canCapture(h)){ toast("Duplicate or too fast. Try a different shot."); return; }

  // Predict
  let topName = "wild beast";
  try{
    const preds = await model.predict(canvas);
    preds.sort((a,b)=>b.probability-a.probability);
    topName = preds[0]?.className?.toLowerCase() || "wild beast";
  }catch(e){ console.warn("Predict error:",e); }

  const entry = MONSTER_DEX[topName] || MONSTER_DEX["wild beast"];
  const rarity = rollRarity();
  const stats = computeStats(entry.class, rarity);

  const monster = {
    id: uid(),
    name: topName,
    display: topName.replace(/\b\w/g,c=>c.toUpperCase()),
    element: entry.element,
    class: entry.class,
    rarity,
    level: 1,
    exp: 0,
    stats,
    img: entry.img,
    hash: h,
    createdAt: Date.now()
  };

  state.monsters.push(monster);
  // Auto-add to team if space
  if(state.team.length<3) state.team.push(monster.id);

  lastCaptureAt=Date.now(); lastHash=h;
  saveState();
  renderAll();

  // Show card immediately
  showMonsterCard(monster, true);
}

/* =========================
   RENDERING
========================= */
function monsterCardHTML(m){
  const hpPct = clamp(Math.round((m.stats.hp)/120*100), 5,100);
  const staPct= clamp(Math.round((m.stats.sta)/120*100),5,100);
  return `
  <div class="monster-card ${rarityGlow(m.rarity)}">
    <div class="monster-head">
      <div class="monster-img"><img src="${m.img}" alt="${m.name}" /></div>
      <div>
        <div style="display:flex;gap:8px;align-items:center;flex-wrap:wrap">
          <div style="font-weight:800;font-size:1.1rem">${m.display}</div>
          <span class="badge" style="border-color:${RARITY_COLOR[m.rarity]};color:${RARITY_COLOR[m.rarity]}">${m.rarity}</span>
          <span class="badge">${m.element}</span>
          <span class="badge">${m.class}</span>
          <span class="badge">Lv ${m.level}</span>
        </div>
        <div class="statgrid">
          <div class="stat">ATK: <b>${m.stats.atk}</b></div>
          <div class="stat">DEF: <b>${m.stats.def}</b></div>
          <div class="stat">SPD: <b>${m.stats.spd}</b></div>
          <div class="stat">EXP: <b>${m.exp}/${xpNeededFor(m.level)}</b></div>
        </div>
        <div style="margin-top:8px">
          <div style="display:flex;align-items:center;gap:8px"><span style="width:58px">HP</span><div class="bar" style="flex:1"><span class="hp" style="width:${hpPct}%"></span></div></div>
          <div style="height:6px"></div>
          <div style="display:flex;align-items:center;gap:8px"><span style="width:58px">STA</span><div class="bar" style="flex:1"><span class="sta" style="width:${staPct}%"></span></div></div>
        </div>
      </div>
    </div>
    <div style="margin-top:8px;display:flex;gap:8px;flex-wrap:wrap">
      <button data-act="team" data-id="${m.id}">Add to Team</button>
      <button data-act="break" data-id="${m.id}" class="ghost">Break → Shards</button>
    </div>
  </div>`;
}
function showMonsterCard(m, scrollIntoView=false){
  $("#resultZone").innerHTML = monsterCardHTML(m);
  $("#resultZone").querySelectorAll("button").forEach(b=>b.addEventListener('click',onMonsterAction));
  if(scrollIntoView) $("#resultZone").scrollIntoView({behavior:"smooth",block:"start"});
}

function renderInventory(){
  $("#invCount").textContent = state.monsters.length;
  const box=$("#inventoryList"); box.innerHTML="";
  state.monsters.forEach(m=>{
    const el=document.createElement('div');
    el.className="slot "+rarityGlow(m.rarity);
    el.innerHTML=`
      <img src="${m.img}" alt="${m.name}" />
      <div class="name">${m.display}</div>
      <div class="rar" style="color:${RARITY_COLOR[m.rarity]}">${m.rarity}</div>
      <div style="display:flex;gap:6px;margin-top:6px">
        <button data-act="view" data-id="${m.id}">View</button>
        <button data-act="team" data-id="${m.id}">Team</button>
        <button data-act="break" data-id="${m.id}" class="ghost">Break</button>
      </div>`;
    box.appendChild(el);
  });
  box.querySelectorAll("button").forEach(b=>b.addEventListener('click', onMonsterAction));
}
function renderTeam(){
  const box=$("#teamSlots"); box.innerHTML="";
  for(let i=0;i<3;i++){
    const m = state.monsters.find(x=>x.id===state.team[i]);
    const el=document.createElement('div'); el.className="slot";
    if(m){
      el.classList.add(rarityGlow(m.rarity));
      el.innerHTML=`
        <img src="${m.img}" />
        <div class="name">${m.display}</div>
        <div class="rar" style="color:${RARITY_COLOR[m.rarity]}">${m.rarity}</div>
        <button data-act="removeTeam" data-id="${m.id}" class="ghost">Remove</button>
      `;
    }else{
      el.innerHTML=`<div style="opacity:.6">Empty</div>`;
    }
    box.appendChild(el);
  }
  box.querySelectorAll("button").forEach(b=>b.addEventListener('click',onMonsterAction));
}
function renderLoot(){
  const box=$("#lootList"); box.innerHTML="";
  const entries = Object.entries(state.loot);
  if(entries.length===0){ box.innerHTML="<div class='pill'>No loot yet</div>"; return; }
  for(const [id,qty] of entries){
    const el=document.createElement('div'); el.className="slot"; el.innerHTML=`<div class="name">${id}</div><div>x${qty}</div>`;
    box.appendChild(el);
  }
  $("#shardCount").textContent = state.loot.shard||0;
  $("#goldCount").textContent  = (state.loot.gold_small||0)+(state.loot.gold_med||0)+(state.loot.gold_big||0);
  $("#matCount").textContent   = (state.loot.mat_wolfFang||0)+(state.loot.mat_dragonScale||0)+(state.loot.mat_krakenEye||0);
}
function renderMythics(){
  const box=$("#mythicList"); box.innerHTML="";
  const mythNames = Object.keys(state.mythicsSeen);
  $("#mythCount").textContent = mythNames.length;
  if(mythNames.length===0){ box.innerHTML="<div class='pill'>No mythics yet</div>"; return; }
  mythNames.forEach(n=>{
    const el=document.createElement('div'); el.className="slot glow-Mythic";
    el.innerHTML=`<div class="name">${n}</div><div class="rar" style="color:${RARITY_COLOR.Mythic}">Mythic</div>`;
    box.appendChild(el);
  });
}
function renderUpgrades(){
  const box=$("#upgradeArea"); box.innerHTML="";
  const wep = state.items.weapon, arm=state.items.armor;

  const itemCard = (t, it) => `
    <div class="monster-card">
      <div style="display:flex;gap:10px;align-items:center">
        <div style="font-weight:800">${t}</div>
        <span class="badge" style="border-color:${RARITY_COLOR[it.rarity]};color:${RARITY_COLOR[it.rarity]}">${it.rarity}</span>
        <span class="badge">Lv ${it.lvl}</span>
      </div>
      <div style="margin-top:8px;display:flex;gap:8px;flex-wrap:wrap">
        <button data-item="${t}" data-act="upgradeItem">Upgrade (+)</button>
        <button data-item="${t}" data-act="ultimateItem" class="ghost">Ultimate (Mythic)</button>
      </div>
      <div style="opacity:.85;margin-top:6px;font-size:.9rem">Upgrades cost shards + gold. Ultimate needs Mythic Core (boss) + level + shards.</div>
    </div>`;
  box.innerHTML = itemCard("Weapon",wep) + itemCard("Armor",arm);
  box.querySelectorAll("button").forEach(b=>b.addEventListener('click', onUpgradeAction));
}

function renderAll(){
  renderInventory(); renderTeam(); renderLoot(); renderMythics(); renderUpgrades();
  $("#killCount").textContent = state.killCount;
}

/* =========================
   ACTION HANDLERS
========================= */
function onMonsterAction(e){
  const act=e.target.dataset.act; const id=e.target.dataset.id;
  const m=state.monsters.find(x=>x.id===id);
  if(act==="view" && m){ showMonsterCard(m,true); }
  if(act==="team" && m){
    if(state.team.includes(id)) return;
    if(state.team.length<3){ state.team.push(id); saveState(); renderTeam(); toast("Added to team"); }
    else toast("Team is full");
  }
  if(act==="removeTeam" && m){
    state.team = state.team.filter(x=>x!==id); saveState(); renderTeam();
  }
  if(act==="break" && m){
    // require level threshold to block breaking fresh mythics if you want (optional)
    const shardsGained = Math.max(1, Math.round((RARITY_MOD[m.rarity]||0)/5));
    addLoot("shard", shardsGained);
    state.monsters = state.monsters.filter(x=>x.id!==id);
    state.team = state.team.filter(x=>x!==id);
    saveState(); renderAll(); toast(`+${shardsGained} shards`);
  }
}

function onUpgradeAction(e){
  const t=e.target.dataset.item; if(!t) return;
  const isUltimate = e.target.dataset.act==="ultimateItem";
  const it = state.items[t.toLowerCase()];
  // Costs
  if(isUltimate){
    const needLvl = 5; // require item lvl 5
    if(it.lvl<needLvl){ toast(`${t} must be Lv ${needLvl} first.`); return; }
    if((state.loot.mythic_core||0)<1){ toast("Need 1 Mythic Core."); return; }
    if((state.loot.shard||0)<5){ toast("Need 5 shards."); return; }
    it.rarity="Mythic"; it.lvl++;
    state.loot.mythic_core--; state.loot.shard-=5;
    toast(`${t} ascended to Mythic!`);
  }else{
    const costShards = Math.max(1, Math.ceil((it.lvl+1)/2));
    if((state.loot.shard||0)<costShards){ toast(`Need ${costShards} shards`); return; }
    state.loot.shard -= costShards; it.lvl++;
    toast(`${t} upgraded to Lv ${it.lvl}`);
  }
  saveState(); renderUpgrades(); renderLoot();
}

/* =========================
   BATTLES
========================= */
function teamPower(){
  return state.team.map(id=>state.monsters.find(m=>m.id===id)).filter(Boolean).reduce((s,m)=>{
    // simple score: atk+def+spd + rarity bonus + item bonuses
    const rb = (RARITY_MOD[m.rarity]||0);
    return s + (m.stats.atk+m.stats.def+m.stats.spd+rb);
  },0) + (state.items.weapon.lvl*5) + (state.items.armor.lvl*5);
}
function randomEncounter(type){ // "wild" | "miniboss" | "boss"
  const pool = {
    wild: { name:["dog","cat","squirrel","spider","fly","ladybug"], hp:[80,120], atk:[35,75], imgKey: null },
    miniboss: { name:["wolf","golem"], hp:[220,300], atk:[70,110], imgKey:"miniboss" },
    boss: { name:["dragon","kraken"], hp:[420,560], atk:[100,150], imgKey:"boss" }
  }[type];

  const pick = pool.name[randInt(0,pool.name.length-1)];
  const img = pool.imgKey==="boss" ? (BOSS_ART[pick]||BOSS_ART.dragon)
           : pool.imgKey==="miniboss" ? (MINIBOSS_ART[pick]||MINIBOSS_ART.wolf)
           : (MONSTER_DEX[pick]?.img || MONSTER_DEX["wild beast"].img);

  return {
    type, name: pick[0].toUpperCase()+pick.slice(1),
    hp: randInt(pool.hp[0], pool.hp[1]),
    atk: randInt(pool.atk[0], pool.atk[1]),
    element: ELEMENTS[randInt(0,ELEMENTS.length-1)],
    img
  };
}
function outcomeChance(youPow, foe){
  let base = 0.55; // make wilds winnable
  if(foe.type==="miniboss") base=0.35;
  if(foe.type==="boss") base=0.12; // ~12% baseline; you asked ~7% or less—final chance also scales below

  // scale by power difference
  const foePow = foe.atk + foe.hp/3;
  const diff = youPow - foePow;
  let mod = diff/600; // soft scaling
  mod = clamp(mod,-0.25,0.25);
  let p = clamp(base + mod, 0.03, (foe.type==="boss"?0.12:0.75));
  return p;
}
function fightNow(type){
  const youPow = teamPower();
  const foe = randomEncounter(type);
  const winP = outcomeChance(youPow,foe);
  const win = Math.random() < winP;

  const area=$("#battleArea");
  area.innerHTML = `
    <div class="monster-card ${type==='boss'?'glow-Mythic': type==='miniboss'?'glow-Legendary':'glow-Rare'}">
      <div class="monster-head">
        <div class="monster-img"><img src="${foe.img}" alt="${foe.name}"/></div>
        <div>
          <div style="font-weight:800">${type.toUpperCase()} — ${foe.name}</div>
          <div class="statgrid">
            <div class="stat">Element: <b>${foe.element}</b></div>
            <div class="stat">HP: <b>${foe.hp}</b></div>
            <div class="stat">ATK: <b>${foe.atk}</b></div>
            <div class="stat">Your Team Power: <b>${youPow}</b></div>
            <div class="stat">Win Chance: <b>${Math.round(winP*100)}%</b></div>
          </div>
        </div>
      </div>
      <div style="margin-top:8px">
        <div style="font-weight:700">${win? "Victory! 🎉":"Defeat 😵"}</div>
        <div id="lootRow" class="row" style="margin-top:8px"></div>
      </div>
    </div>`;

  if(win){
    state.killCount++; $("#killCount").textContent=state.killCount;
    // Reward EXP to team
    const expGain = (type==="boss"? 60 : type==="miniboss"? 35 : 18);
    for(const id of state.team){
      const m = state.monsters.find(x=>x.id===id); if(!m) continue;
      m.exp += expGain;
      while(m.exp >= xpNeededFor(m.level)){
        m.exp -= xpNeededFor(m.level);
        m.level++;
        // small stat bumps on level
        m.stats.hp += 4; m.stats.sta += 3; m.stats.atk += 2; m.stats.def += 2; m.stats.spd += 2;
      }
    }
    saveState(); renderTeam(); renderInventory();

    // Drops
    const table = LOOT_TABLE[type];
    const drops=[];
    for(const entry of table){
      if(Math.random() < entry.chance){
        const qty = Array.isArray(entry.qty)? randInt(entry.qty[0], entry.qty[1]) : entry.qty;
        drops.push({id:entry.id, name:entry.name, qty, rarity:entry.rarity});
        state.loot[entry.id]=(state.loot[entry.id]||0)+qty;
        // Track mythic discovery
        if(entry.id==="mythic_core"||entry.id==="ultra_mythic_spark"){
          cinematicReveal(entry);
        }
      }
    }
    saveState(); renderLoot();
    showDrops(drops);
  }else{
    toast("You retreated to recover…");
  }
}

function showDrops(drops){
  const row=$("#lootRow");
  row.innerHTML="";
  if(drops.length===0){ row.innerHTML="<div class='pill'>No loot</div>"; return; }
  drops.forEach(d=>{
    const el=document.createElement('div');
    el.className="pill";
    el.style.borderColor="#444";
    el.style.background="#1e1e1e";
    el.textContent = `${d.name} x${d.qty}`;
    row.appendChild(el);

    // fly to inventory animation
    const img=document.createElement('div');
    img.className="loot-fly";
    img.textContent="📦";
    img.style.left="50%"; img.style.bottom="120px";
    document.body.appendChild(img);
    setTimeout(()=>{ img.style.transform="translate(360px,-420px) scale(0.6)"; img.style.opacity="0"; },10);
    setTimeout(()=>img.remove(),900);
  });
  toast("Loot sent to Inventory");
}

function cinematicReveal(entry){
  const modal=$("#cinematic");
  $("#cinTitle").textContent = entry.id==="ultra_mythic_spark" ? "ULTRA-MYTHIC CHANCE!" : "MYTHIC DISCOVERED!";
  $("#cinImg").src = BOSS_ART.dragon; // generic icon; swap to a mythic emblem later
  $("#cinImg").classList.add("silhouette");
  $("#cinText").innerHTML = `
    <div style="color:${RARITY_COLOR.Mythic};font-weight:800;margin-bottom:6px">${entry.name}</div>
    <div>You found a ${entry.name}. Combine this with shards and levels to unlock an Ultimate upgrade!</div>
  `;
  modal.classList.add("show");
}

/* =========================
   TABS & EVENTS
========================= */
function switchTab(tab){
  $$(".tab").forEach(t=>t.classList.toggle("active", t.dataset.tab===tab));
  ["inventory","team","battle","upgrades","loot","mythic"].forEach(id=>{
    $("#panel-"+id).style.display = (id===tab) ? "block" : "none";
  });
}
$$(".tab").forEach(t=>t.addEventListener('click', ()=>switchTab(t.dataset.tab)));
$("#cinClose").addEventListener('click', ()=> $("#cinematic").classList.remove('show'));

// Buttons
$("#btnStartCam").addEventListener('click', startCamera);
$("#btnStopCam").addEventListener('click', stopCamera);
$("#btnCapture").addEventListener('click', captureFromVideo);
$("#btnUpload").addEventListener('click', ()=>$("#fileInput").click());
$("#fileInput").addEventListener('change', e=>{
  const f=e.target.files?.[0]; if(f) captureFromFile(f);
});

// Battle buttons
$("#btnWild").addEventListener('click', ()=>fightNow("wild"));
$("#btnMiniBoss").addEventListener('click', ()=>fightNow("miniboss"));
$("#btnBoss").addEventListener('click',  ()=>fightNow("boss"));

/* =========================
   INIT
========================= */
(async function boot(){
  try{ await loadModel(); }catch(e){ console.error("Model load failed:",e); }
  renderAll();
})();
</script>
</body>
</html>  }
  .btn.secondary{ background:#2d3640; color:#d6e7ff }
  .btn.warn{ background:var(--warn); color:#1b1302 }
  .btn.danger{ background:var(--danger) }
  .btn.ok{ background:var(--ok); color:#02140a }
  .btn:disabled{opacity:.5; cursor:not-allowed}

  .camShell{position:relative; background:#000; border-radius:12px; overflow:hidden; border:2px solid #39424c}
  video, canvas{width:100%; height:auto; display:block; background:#000}
  .devicePick{width:100%; background:#1f2730; color:var(--ink); border:1px solid #303a45; border-radius:10px; padding:10px}

  .log{white-space:pre-wrap; background:#0f0f0f; border:1px solid #2a2a2a; color:#c6d1e5; padding:8px; border-radius:10px; min-height:60px; text-align:left}
  .chip{display:inline-block; background:var(--chip); padding:4px 8px; border-radius:999px; font-size:12px; opacity:.9}

  .collection{display:grid; grid-template-columns:1fr; gap:10px}
  .kpi{display:flex; gap:8px; align-items:center; padding:8px 10px}
  .kpi .pill{background:#212a33; border:1px solid #2e3743; border-radius:999px; padding:6px 10px}

  .monsterGrid{display:grid; grid-template-columns:repeat(2,1fr); gap:10px}
  @media (max-width:540px){ .monsterGrid{grid-template-columns:1fr} }

  .mCard{background:#13181d; border:1px solid #29313a; border-radius:12px; overflow:hidden}
  .mCard img{width:100%; display:block; aspect-ratio:16/10; object-fit:cover; background:#0b0b0b}
  .mBody{padding:10px}
  .mTop{display:flex; align-items:center; justify-content:space-between; gap:10px}
  .mName{font-weight:800; letter-spacing:.3px}
  .rar{font-size:12px; padding:2px 8px; border-radius:999px; border:1px solid #2d3440}
  .rar.common{background:#1f2630; color:#b7c0d4}
  .rar.uncommon{background:#173126; color:#a8e6c3; border-color:#285a43}
  .rar.rare{background:#2a1837; color:#e7befc; border-color:#6741a0}
  .stats{display:grid; grid-template-columns:repeat(2,1fr); gap:6px; margin-top:8px}
  .stat{background:#101419; border:1px solid #222a33; padding:6px 8px; border-radius:8px; font-size:13px}
  .actions{display:flex; gap:8px; margin-top:8px}
  .teamRow{display:grid; grid-template-columns:repeat(3,1fr); gap:10px}
  .slot{min-height:84px; border:1px dashed #3a3a3a; border-radius:12px; display:grid; place-items:center; background:#0f1419}
  .slot .hint{opacity:.7; font-size:12px}

  .modalMask{position:fixed; inset:0; background:rgba(0,0,0,.6); display:none; place-items:center; z-index:50}
  .modal{background:var(--panel); border:1px solid #2c363f; border-radius:12px; max-width:520px; width:92%; padding:12px}
  .modal h3{margin:8px 0 6px}
</style>
</head>
<body>
  <header>
    <h1>Monster Transform Game</h1>
    <p>Capture a real creature and see its monster form. Works on desktop, Android, and iPhone (HTTPS).</p>
  </header>

  <main class="wrap">
    <!-- LEFT: Capture / Upload -->
    <section class="card">
      <div class="head">Capture</div>
      <div class="pad">
        <div id="status" class="chip">Initializing…</div>
        <div class="camShell" style="margin-top:10px;">
          <video id="webcam" playsinline muted></video>
          <canvas id="frame" hidden></canvas>
        </div>

        <div class="row" style="margin-top:10px;">
          <button id="btnEnable" class="btn">🎥 Enable Camera</button>
          <button id="btnCapture" class="btn secondary" disabled>📸 Capture Photo</button>
          <label class="btn secondary">
            ⬆️ Upload Photo
            <input id="uploader" type="file" accept="image/*" hidden>
          </label>
          <select id="deviceSel" class="devicePick"></select>
        </div>

        <div id="log" class="log" style="margin-top:10px;">Log: ready.</div>
      </div>
    </section>

    <!-- RIGHT: Collection / Team -->
    <section class="card">
      <div class="head">Your Collection</div>
      <div class="pad collection">
        <div class="kpi">
          <div class="pill">Upgrade Dust: <span id="dust">0</span></div>
          <div class="pill">Team: <span id="teamCount">0</span>/3</div>
          <div class="pill">Inventory: <span id="invCount">0</span>/20</div>
        </div>

        <h3>Team</h3>
        <div id="team" class="teamRow"></div>

        <h3 style="margin-top:10px;">Inventory</h3>
        <div id="inventory" class="monsterGrid"></div>

        <div class="row" style="margin-top:12px;">
          <button id="btnWild" class="btn">⚔️ Wild Battle</button>
          <button id="btnBoss" class="btn warn">👹 Boss Hunt</button>
          <span class="chip">Battles auto-resolve for now.</span>
        </div>
      </div>
    </section>
  </main>

  <!-- Force-breakdown modal -->
  <div id="modalMask" class="modalMask">
    <div class="modal">
      <h3>Inventory Full</h3>
      <p>You can store up to 20 monsters. Pick one to <strong>break down</strong> into shards to make room.</p>
      <div id="modalList" class="monsterGrid" style="max-height:50vh; overflow:auto;"></div>
      <div class="row" style="margin-top:10px; justify-content:flex-end;">
        <button id="modalCancel" class="btn secondary">Cancel</button>
      </div>
    </div>
  </div>

<script>
/* -----------------------------
   CONFIG / CONSTANTS
------------------------------*/
const MODEL_URL = "model_real/"; // model.json, metadata.json, weights.bin in this folder

// Optional: when you add a second model (e.g., bird) you can switch by changing this:
// const MODEL_URL = "models/bird/";

// Map model className -> digital artwork (in /digital_images/)
const DIGITAL_ART = {
  ladybug: "digital_images/ladybug.jpeg",
  squirrel:"digital_images/squirrel.jpeg",
  dog:     "digital_images/dog.jpeg",
  cat:     "digital_images/cat.jpeg",
  spider:  "digital_images/spider.jpeg",
  fly:     "digital_images/fly.jpeg",
  // add more here as you create art: "bird":"digital_images/bird.jpeg"
};

// Base stat templates by archetype (then adjusted by rarity + small randomness)
const ARCHETYPES = {
  // {hp, atk, def, spd, crit, element, class}
  ladybug: { hp:90,  atk:40, def:90, spd:35, crit:8,  element:"Light",  class:"Guardian" },
  squirrel:{ hp:70,  atk:55, def:60, spd:90, crit:16, element:"Nature", class:"Skirmisher"},
  dog:     { hp:85,  atk:60, def:75, spd:55, crit:10, element:"Earth",  class:"Guardian" },
  cat:     { hp:65,  atk:88, def:45, spd:92, crit:18, element:"Shadow", class:"Assassin" },
  spider:  { hp:72,  atk:55, def:68, spd:60, crit:12, element:"Poison", class:"Trapper" },
  fly:     { hp:50,  atk:40, def:35, spd:99, crit:14, element:"Air",    class:"Scout"  },
  // you can add others matching your model classes later
};

// Battle pool (wild + bosses). Bosses are very hard.
const WILD_POOL = [
  { name:"wild-cat",     base:{hp:70, atk:60, def:45, spd:70, crit:10}, element:"Shadow", class:"Skirmisher" },
  { name:"wild-dog",     base:{hp:85, atk:60, def:70, spd:55, crit: 9}, element:"Earth",  class:"Guardian"  },
  { name:"wild-ladybug", base:{hp:90, atk:40, def:90, spd:35, crit: 8}, element:"Light",  class:"Guardian"  },
  { name:"wild-spider",  base:{hp:75, atk:52, def:70, spd:62, crit:11}, element:"Poison", class:"Trapper"   },
  { name:"wild-squirrel",base:{hp:68, atk:58, def:60, spd:88, crit:15}, element:"Nature", class:"Skirmisher"},
  { name:"wild-fly",     base:{hp:50, atk:40, def:35, spd:95, crit:14}, element:"Air",    class:"Scout"     },
];
const BOSS_POOL = [
  { name:"Boss Tiger",      boss:true, base:{hp:320, atk:95,  def:80,  spd:85,  crit:16}, element:"Savanna", class:"Predator" },
  { name:"Boss Bear",       boss:true, base:{hp:420, atk:85,  def:110, spd:55,  crit:10}, element:"Earth",   class:"Juggernaut" },
  { name:"Boss Shark",      boss:true, base:{hp:360, atk:100, def:85,  spd:80,  crit:18}, element:"Water",   class:"Ravager" },
  { name:"Boss Lion",       boss:true, base:{hp:340, atk:98,  def:88,  spd:82,  crit:17}, element:"Savanna", class:"Predator" },
  { name:"Boss Snake",      boss:true, base:{hp:300, atk:88,  def:70,  spd:90,  crit:22}, element:"Poison",  class:"Ambusher" },
  { name:"Boss Alligator",  boss:true, base:{hp:380, atk:92,  def:105, spd:60,  crit:12}, element:"Water",   class:"Guardian" },
  { name:"Boss Pelican",    boss:true, base:{hp:360, atk:84,  def:80,  spd:88,  crit:14}, element:"Air",     class:"Overlord" }
];

// Rarity chances and multipliers
const RARITY_TABLE = [
  { key:"rare",      chance: 0.01, mult: 1.18 }, // ~1%, noticeably stronger
  { key:"uncommon",  chance: 0.15, mult: 1.12 }, // 15%
  { key:"common",    chance: 0.84, mult: 1.00 }, // rest
];

// inventory limits
const INV_LIMIT = 20;
const TEAM_LIMIT = 3;

/* -----------------------------
   STATE / STORAGE
------------------------------*/
const S = {
  monsters: [], // inventory
  team: [],     // array of monster ids
  dust: 0,
  nextId: 1,
};
const LS_KEY = "lenslair_save_v2";

function loadState(){
  try{
    const raw = localStorage.getItem(LS_KEY);
    if(raw){
      const obj = JSON.parse(raw);
      Object.assign(S, obj);
    }
  }catch(e){ console.warn("Load state error:", e); }
}
function saveState(){
  localStorage.setItem(LS_KEY, JSON.stringify(S));
}
function wipeState(){
  localStorage.removeItem(LS_KEY);
  location.reload();
}

/* -----------------------------
   UTIL
------------------------------*/
function log(msg){ const el = document.getElementById("log"); el.textContent = (el.textContent + "\n" + msg).slice(-2000); }
function byId(id){ return document.getElementById(id); }
function randInt(min,max){ return Math.floor(Math.random()*(max-min+1))+min; }
function pickRarity(){
  let r = Math.random();
  let acc = 0;
  for(const row of RARITY_TABLE){
    acc += row.chance;
    if(r <= acc) return row;
  }
  return RARITY_TABLE[RARITY_TABLE.length-1];
}
function statRoll(base, mult){
  // slight randomization around the multiplier (±4%)
  const jitter = 1 + (Math.random()*0.08 - 0.04);
  return Math.max(1, Math.round(base * mult * jitter));
}
function imgOrPlaceholder(name){
  const src = DIGITAL_ART[name?.toLowerCase()];
  return src || "https://dummyimage.com/640x360/0a0a0a/ffffff&text=Monster";
}

/* -----------------------------
   CAMERA / MODEL
------------------------------*/
let model = null, metadata = null;
let stream = null;
const video = byId("webcam");
const canvas = byId("frame");
const deviceSel = byId("deviceSel");
const statusChip = byId("status");

async function loadModel(){
  try{
    model = await tmImage.load(MODEL_URL + "model.json", MODEL_URL + "metadata.json");
    metadata = model?.getTotalClasses?.() ?? null;
    log("✅ Model loaded");
    statusChip.textContent = "Model ready.";
  }catch(e){
    log("⚠️ Model load failed — capturing will still create a monster via fallback. " + e.message);
    statusChip.textContent = "Model unavailable (fallback active)";
  }
}

// enumerate devices for camera selection (helps iOS/Android)
async function refreshDevices(){
  try{
    const list = await navigator.mediaDevices.enumerateDevices();
    const cams = list.filter(d => d.kind === "videoinput");
    deviceSel.innerHTML = "";
    cams.forEach((d, i)=>{
      const o = document.createElement("option");
      o.value = d.deviceId;
      o.textContent = d.label || `Camera ${i+1}`;
      deviceSel.appendChild(o);
    });
    if(cams.length===0){
      const o = document.createElement("option");
      o.value = "";
      o.textContent = "No camera found";
      deviceSel.appendChild(o);
    }
  }catch(e){ log("enumerateDevices error: " + e.message); }
}

async function startCamera(deviceId){
  if(stream){ stream.getTracks().forEach(t=>t.stop()); stream=null; }
  const constraints = deviceId
    ? { video: { deviceId: { exact: deviceId } } }
    : { video: { facingMode: { ideal:"environment" } } };

  try{
    stream = await navigator.mediaDevices.getUserMedia(constraints);
    video.srcObject = stream;
    await video.play();
    statusChip.textContent = "Camera ready.";
    byId("btnCapture").disabled = false;
    log("🎥 Camera started");
  }catch(e){
    log("Camera error: " + e.name + " — " + e.message);
    statusChip.textContent = "Camera failed. Try a different device above or use Upload.";
    byId("btnCapture").disabled = true;
  }
}

function drawCurrentFrame(){
  const w = video.videoWidth || 640, h = video.videoHeight || 480;
  canvas.width = w; canvas.height = h;
  const ctx = canvas.getContext("2d");
  ctx.drawImage(video, 0, 0, w, h);
  return canvas;
}

/* -----------------------------
   MONSTER CREATION
------------------------------*/
function createFromClassName(cls){
  // base from archetype (or generic if unknown)
  const key = (cls||"").toLowerCase();
  const base = ARCHETYPES[key] || { hp:70, atk:60, def:60, spd:60, crit:10, element:"Neutral", class:"Adventurer" };
  const art = imgOrPlaceholder(key);

  const rarityRow = pickRarity(); // rare/uncommon/common
  const mult = rarityRow.mult;

  const monster = {
    id: S.nextId++,
    name: key || "unknown",
    element: base.element,
    class: base.class,
    rarity: rarityRow.key,
    art,
    // rolled stats
    hp:  statRoll(base.hp,  mult),
    atk: statRoll(base.atk, mult),
    def: statRoll(base.def, mult),
    spd: statRoll(base.spd, mult),
    crit:statRoll(base.crit,mult),
    lvl:1, xp:0,
    ts: Date.now()
  };
  return monster;
}

async function classifyCanvas(canv){
  if(!model){
    log("Model not loaded, using fallback class.");
    return null;
  }
  const preds = await model.predict(canv);
  preds.sort((a,b)=>b.probability-a.probability);
  const top = preds[0];
  if(!top || top.probability < 0.40){
    log("Low confidence ("+(top?.probability?.toFixed(2)??"n/a")+") — using fallback.");
    return null;
  }
  return (top.className||"").toLowerCase();
}

async function pipelineFromCanvas(canv){
  // classify → build monster → enforce capacity → render/save
  let cls = null;
  try{ cls = await classifyCanvas(canv); }
  catch(e){ log("Prediction failed: " + e.message); }

  const monster = createFromClassName(cls);
  await ensureCapacityOrBreakdown(); // may open modal
  S.monsters.push(monster);
  saveState();
  renderAll();
  log(`✨ Created ${monster.rarity.toUpperCase()} ${monster.name.toUpperCase()} (HP:${monster.hp} ATK:${monster.atk})`);
}

/* -----------------------------
   INVENTORY CAP / BREAKDOWN
------------------------------*/
const mask = byId("modalMask"), modalList = byId("modalList"), modalCancel = byId("modalCancel");
modalCancel.addEventListener("click", ()=> mask.style.display="none");

async function ensureCapacityOrBreakdown(){
  if(S.monsters.length < INV_LIMIT) return;
  // Force user to break one down
  return new Promise(resolve=>{
    modalList.innerHTML = "";
    S.monsters.forEach(m=>{
      const card = miniCard(m, [
        {label:"Break for Shards", cls:"danger", onClick:()=>{
          const shards = m.rarity==="rare" ? 40 : m.rarity==="uncommon" ? 18 : 8;
          S.dust += shards;
          // also drop from team if present
          S.team = S.team.filter(id=>id!==m.id);
          S.monsters = S.monsters.filter(x=>x.id!==m.id);
          saveState(); renderAll();
          resolve();
          mask.style.display="none";
        }}
      ]);
      modalList.appendChild(card);
    });
    mask.style.display="grid";
  });
}

/* -----------------------------
   RENDERING
------------------------------*/
function monsterCard(mon, ctx="inventory"){
  const el = document.createElement("div");
  el.className = "mCard";
  el.innerHTML = `
    <img src="${mon.art}" alt="${mon.name}">
    <div class="mBody">
      <div class="mTop">
        <div class="mName">${mon.name.toUpperCase()} • <span style="opacity:.8">${mon.element}</span></div>
        <div class="rar ${mon.rarity}">${mon.rarity}</div>
      </div>
      <div class="stats">
        <div class="stat">HP: <b>${mon.hp}</b></div>
        <div class="stat">ATK: <b>${mon.atk}</b></div>
        <div class="stat">DEF: <b>${mon.def}</b></div>
        <div class="stat">SPD: <b>${mon.spd}</b></div>
        <div class="stat">CRIT: <b>${mon.crit}%</b></div>
        <div class="stat">LVL: <b>${mon.lvl}</b></div>
      </div>
      <div class="actions"></div>
    </div>`;
  const acts = el.querySelector(".actions");

  if(ctx==="inventory"){
    // add to team (if there is space)
    const b1 = button("Add to Team", "ok", ()=>{
      if(S.team.includes(mon.id)) return;
      if(S.team.length >= TEAM_LIMIT){ alert("Team is full (3). Remove one first."); return; }
      S.team.push(mon.id); saveState(); renderAll();
    });
    const b2 = button("Breakdown", "danger", ()=>{
      const shards = mon.rarity==="rare" ? 40 : mon.rarity==="uncommon" ? 18 : 8;
      if(!confirm(`Break ${mon.name.toUpperCase()} for ${shards} shards?`)) return;
      S.dust += shards;
      S.monsters = S.monsters.filter(x=>x.id!==mon.id);
      S.team = S.team.filter(id=>id!==mon.id);
      saveState(); renderAll();
    });
    acts.append(b1,b2);
  }else if(ctx==="team"){
    const b1 = button("Remove", "secondary", ()=>{
      S.team = S.team.filter(id=>id!==mon.id);
      saveState(); renderAll();
    });
    acts.append(b1);
  }
  return el;
}
function miniCard(mon, actions=[]){
  const el = document.createElement("div");
  el.className = "mCard";
  el.innerHTML = `
    <img src="${mon.art}" alt="${mon.name}">
    <div class="mBody">
      <div class="mTop"><div class="mName">${mon.name.toUpperCase()}</div><div class="rar ${mon.rarity}">${mon.rarity}</div></div>
      <div class="stats">
        <div class="stat">HP:${mon.hp}</div>
        <div class="stat">ATK:${mon.atk}</div>
      </div>
      <div class="actions"></div>
    </div>`;
  const acts = el.querySelector(".actions");
  actions.forEach(a=>{
    const b = button(a.label, a.cls, a.onClick); acts.appendChild(b);
  });
  return el;
}
function button(txt, cls, onClick){
  const b = document.createElement("button");
  b.className = "btn " + (cls||"");
  b.textContent = txt;
  b.addEventListener("click", onClick);
  return b;
}

function renderAll(){
  byId("dust").textContent = S.dust;
  byId("invCount").textContent = S.monsters.length;
  byId("teamCount").textContent = S.team.length;

  // team view
  const teamEl = byId("team");
  teamEl.innerHTML = "";
  for(let i=0;i<TEAM_LIMIT;i++){
    const id = S.team[i];
    if(id){
      const mon = S.monsters.find(x=>x.id===id);
      if(mon) teamEl.appendChild(monsterCard(mon,"team"));
      else{
        // clean up dangling ids
        S.team = S.team.filter(tid => S.monsters.some(m=>m.id===tid));
        saveState();
      }
    }else{
      const slot = document.createElement("div");
      slot.className = "slot";
      slot.innerHTML = `<div class="hint">Empty slot</div>`;
      teamEl.appendChild(slot);
    }
  }
  // inventory
  const invEl = byId("inventory");
  invEl.innerHTML = "";
  S.monsters
    .filter(m => !S.team.includes(m.id))
    .sort((a,b)=>b.ts-a.ts)
    .forEach(m=> invEl.appendChild(monsterCard(m,"inventory")));
}

/* -----------------------------
   BATTLES (auto-resolve)
------------------------------*/
function basicDuel(a, b){
  // very quick auto resolution: each turn, damage = atk * (100/(100+def)) * variance
  function dmg(att, def){
    const raw = att * (100/(100 + def));
    const variance = 0.85 + Math.random()*0.3;
    let crit = 1;
    if(Math.random() < (att.crit||10)/100) crit = 1.5;
    return Math.max(1, Math.round(raw * variance * crit));
  }
  let ahp=a.hp, bhp=b.hp;
  let turns=0;
  while(ahp>0 && bhp>0 && turns<200){
    // initiative: higher spd first; tie random
    const first = (a.spd===b.spd) ? (Math.random()<0.5?a:b) : ((a.spd>b.spd)?a:b);
    const second = (first===a)?b:a;
    if(first===a){ bhp -= dmg(a,b); if(bhp<=0) break; ahp -= dmg(b,a); }
    else        { ahp -= dmg(b,a); if(ahp<=0) break; bhp -= dmg(a,b); }
    turns++;
  }
  return ahp>0 ? "player" : "enemy";
}

function pickWild(boss=false){
  const src = boss ? BOSS_POOL : WILD_POOL;
  const x = src[Math.floor(Math.random()*src.length)];
  return {
    name: x.name,
    element: x.element,
    class: x.class,
    rarity: boss ? "boss" : "wild",
    art: imgOrPlaceholder(x.name.includes("wild-") ? x.name.split("wild-")[1] : x.name),
    ...x.base
  };
}

function runBattle(boss=false){
  if(S.team.length===0){ alert("Add at least one monster to your team first."); return; }

  // build combined team power (sum of top 3)
  const teamMons = S.team.map(id => S.monsters.find(m=>m.id===id)).filter(Boolean);
  const teamFighter = {
    name:"Your Team",
    hp: teamMons.reduce((s,m)=>s+m.hp,0),
    atk:Math.round(teamMons.reduce((s,m)=>s+m.atk,0)/teamMons.length),
    def:Math.round(teamMons.reduce((s,m)=>s+m.def,0)/teamMons.length),
    spd:Math.round(teamMons.reduce((s,m)=>s+m.spd,0)/teamMons.length),
    crit:Math.round(teamMons.reduce((s,m)=>s+m.crit,0)/teamMons.length),
  };

  // enemy
  const enemy = pickWild(boss);

  const who = basicDuel(teamFighter, enemy);
  if(who==="player"){
    const reward = boss ? 120 : 25 + Math.round(Math.random()*20);
    S.dust += reward;
    saveState(); renderAll();
    alert(`Victory!\nYou defeated ${enemy.name} and gained ${reward} dust.`);
  }else{
    alert(`Defeat… ${enemy.name} was too strong this time.`);
  }
}

/* -----------------------------
   EVENT WIRING
------------------------------*/
byId("btnEnable").addEventListener("click", async ()=>{
  if(location.protocol!=="https:"){
    alert("On mobile Safari/Chrome, camera requires HTTPS (GitHub Pages is fine). Upload still works.");
  }
  await refreshDevices();
  const id = deviceSel.value || undefined;
  await startCamera(id);
});

deviceSel.addEventListener("change", async (e)=>{ await startCamera(e.target.value); });

byId("btnCapture").addEventListener("click", async ()=>{
  try{
    const canv = drawCurrentFrame();
    await pipelineFromCanvas(canv);
  }catch(e){
    log("Capture flow error: " + e.message);
  }
});

byId("uploader").addEventListener("change", async (e)=>{
  const file = e.target.files?.[0];
  if(!file) return;
  try{
    const img = new Image();
    img.onload = async ()=>{
      canvas.width = img.naturalWidth; canvas.height = img.naturalHeight;
      const ctx = canvas.getContext("2d");
      ctx.drawImage(img, 0, 0);
      await pipelineFromCanvas(canvas);
    };
    img.src = URL.createObjectURL(file);
  }catch(err){
    log("Upload flow error: " + err.message);
  }finally{
    e.target.value = "";
  }
});

byId("btnWild").addEventListener("click", ()=> runBattle(false));
byId("btnBoss").addEventListener("click", ()=> runBattle(true));

/* -----------------------------
   BOOT
------------------------------*/
(async function boot(){
  loadState();
  renderAll();
  statusChip.textContent = "Loading model…";
  await loadModel();
  await refreshDevices();
  log("Tip: If camera fails on mobile, pick a different device from the dropdown, or use Upload.");
})();
</script>
</body>
</html>

