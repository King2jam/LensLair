<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Monster Transform ‚Äî Offline PVPVE Beta</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<style>
  :root{
    --bg:#0f1220; --panel:#161a2e; --panel-2:#1e2442; --text:#e8ecff; --muted:#a9b2d0;
    --accent:#7aa2ff; --good:#30cf7b; --bad:#ff5a67; --warn:#ffb020;
    --common:#9aa3b2; --uncommon:#4cd964; --rare:#6c8cff; --boss:#ff6f61; --mythic:#ff4dff;
    --shadow:0 10px 30px rgba(0,0,0,.35);
  }
  *{box-sizing:border-box}
  body{margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,Inter,Arial,sans-serif;background:linear-gradient(180deg,#0c1020 0%,#0e1226 100%);color:var(--text)}
  header{padding:14px 16px;background:#0a0e1d;border-bottom:1px solid #242a48;position:sticky;top:0;z-index:5}
  h1{margin:0;font-size:18px;letter-spacing:.4px}
  #tabs{display:flex;gap:8px;flex-wrap:wrap;margin-top:10px}
  .tab{padding:8px 12px;border-radius:999px;background:var(--panel);color:var(--text);cursor:pointer;border:1px solid #263058}
  .tab.active{background:var(--accent);border-color:transparent;color:#06122e;font-weight:700}
  main{padding:16px;max-width:1100px;margin:0 auto}
  .grid{display:grid;gap:16px}
  .grid-2{grid-template-columns:1fr}
  @media(min-width:880px){.grid-2{grid-template-columns:1.2fr .8fr}}
  .card{background:linear-gradient(180deg,var(--panel) 0%,var(--panel-2) 100%);border:1px solid #2a325e;border-radius:18px;padding:14px;box-shadow:var(--shadow)}
  .card h2{margin:.1rem 0 .6rem 0;font-size:18px}
  .muted{color:var(--muted);font-size:14px}
  .row{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
  button, .btn{background:#263058;color:#e4ebff;border:1px solid #34407a;border-radius:12px;padding:10px 12px;font-weight:600;cursor:pointer}
  button.primary{background:var(--accent);color:#06122e;border-color:transparent}
  button.ghost{background:transparent;border-color:#34407a}
  button:disabled{opacity:.55;cursor:not-allowed}
  input[type="file"]{display:none}
  label.file{display:inline-flex;align-items:center;gap:8px;padding:10px 12px;border-radius:12px;border:1px dashed #3a457f;background:rgba(122,162,255,.06);cursor:pointer}
  video, canvas, img.preview{width:100%;max-height:52vh;object-fit:contain;border-radius:14px;border:1px solid #2b3566;background:#0b0f23}
  .stats{display:grid;grid-template-columns:1fr 1fr;gap:10px;margin-top:10px}
  .bar{height:14px;background:#0b0f1a;border:1px solid #2b3566;border-radius:999px;overflow:hidden}
  .bar>span{display:block;height:100%}
  .hp{background:linear-gradient(90deg,#ff6d6d,#ff2e4f)}
  .stam{background:linear-gradient(90deg,#4cf098,#0ecf66)}
  .glow{box-shadow:0 0 0 2px rgba(255,255,255,.05), 0 0 30px rgba(122,162,255,.25) inset}
  .pill{padding:6px 10px;border-radius:999px;border:1px solid #2f386d;background:#1a1f39;font-size:12px}
  .rarity-common{color:#c7ceda}
  .rarity-uncommon{color:var(--uncommon)}
  .rarity-rare{color:var(--rare)}
  .rarity-boss{color:var(--boss)}
  .rarity-mythic{color:var(--mythic)}
  .list{display:grid;gap:10px}
  .item{display:flex;justify-content:space-between;align-items:center;padding:10px;border:1px solid #2a325e;border-radius:12px;background:#161b33}
  .mono{font-family:ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace}
  .hidden{display:none}
  .fly{position:fixed;pointer-events:none;z-index:99;transition:transform .8s ease, opacity .8s ease}
  .codex-grid{display:grid;grid-template-columns:repeat(auto-fill,minmax(180px,1fr));gap:12px}
  .codex-card{background:#141a34;border:1px solid #2b3566;border-radius:14px;padding:8px;text-align:center}
  .codex-card img{width:100%;height:110px;object-fit:contain}
  .silhouette{filter:brightness(0) contrast(200%)}
  .footer{opacity:.7;font-size:12px;margin-top:8px}
  /* Rarity outline glow on monster card border */
  .outline-common{box-shadow:0 0 0 2px var(--common) inset}
  .outline-uncommon{box-shadow:0 0 0 2px var(--uncommon) inset}
  .outline-rare{box-shadow:0 0 0 2px var(--rare) inset}
  .outline-boss{box-shadow:0 0 0 2px var(--boss) inset}
  .outline-mythic{box-shadow:0 0 0 2px var(--mythic) inset}
</style>
</head>
<body>
<header>
  <h1>Monster Transform ‚Äî PVPVE Beta (Offline-Ready)</h1>
  <div id="tabs">
    <div class="tab active" data-tab="capture">Capture</div>
    <div class="tab" data-tab="battles">Battles</div>
    <div class="tab" data-tab="inventory">Inventory</div>
    <div class="tab" data-tab="team">Team</div>
    <div class="tab" data-tab="codex">Codex</div>
    <div class="tab" data-tab="mythic">Mythics</div>
    <div class="tab" data-tab="settings">Settings</div>
  </div>
</header>

<main>
  <!-- CAPTURE -->
  <section id="capture" class="grid grid-2">
    <div class="card">
      <h2>Camera</h2>
      <p class="muted">Aim at a supported animal. High confidence is required to prevent abuse. If camera won‚Äôt start, try toggling front/rear or use Upload.</p>
      <div class="row" style="gap:6px;margin-bottom:8px">
        <button id="btnStart" class="primary">Start Camera</button>
        <button id="btnFlip" class="ghost">Flip Front/Rear</button>
        <label class="file">
          <input id="fileInput" type="file" accept="image/*" />
          üìÅ Upload Photo
        </label>
        <span class="muted" id="camStatus"></span>
      </div>
      <video id="webcam" autoplay playsinline muted class="glow"></video>
      <canvas id="frame" class="hidden"></canvas>
      <div class="row" style="margin-top:10px">
        <button id="btnCapture" disabled>üì∏ Capture</button>
        <button id="btnRetake" class="ghost" disabled>Retake</button>
      </div>
      <div id="errorBox" class="muted" style="color:#ff98a8;margin-top:8px"></div>
    </div>

    <div class="card">
      <h2>Result</h2>
      <div id="resultBox" class="muted">No capture yet.</div>
    </div>
  </section>

  <!-- BATTLES -->
  <section id="battles" class="hidden">
    <div class="grid grid-2">
      <div class="card">
        <h2>Quick Battle</h2>
        <p class="muted">Fight a random enemy. Mini-bosses and Bosses appear sometimes. Loot scales with difficulty. </p>
        <div class="row">
          <button id="btnWild">Wild Battle</button>
          <button id="btnMini">Mini-Boss</button>
          <button id="btnBoss">Boss</button>
        </div>
        <div id="battleView" style="margin-top:12px"></div>
      </div>
      <div class="card">
        <h2>Kill Counters</h2>
        <div id="killCounts" class="list"></div>
        <div class="footer">Counters help track future achievements.</div>
      </div>
    </div>
  </section>

  <!-- INVENTORY -->
  <section id="inventory" class="hidden">
    <div class="card">
      <h2>Shards & Items</h2>
      <div id="invList" class="list"></div>
      <div class="footer">Duplicates stack. Capacity is soft-limited; you‚Äôll be prompted when full to break down extras.</div>
    </div>
  </section>

  <!-- TEAM -->
  <section id="team" class="hidden">
    <div class="grid grid-2">
      <div class="card">
        <h2>Your Team (3)</h2>
        <div id="teamSlots" class="list"></div>
        <div class="row" style="margin-top:10px">
          <button id="btnSaveTeam" class="primary">Save Team</button>
          <button id="btnClearTeam" class="ghost">Clear Team</button>
        </div>
      </div>
      <div class="card">
        <h2>All Monsters</h2>
        <div id="monsterList" class="list"></div>
      </div>
    </div>
  </section>

  <!-- CODEX -->
  <section id="codex" class="hidden">
    <div class="card">
      <h2>Monster Codex</h2>
      <p class="muted">Silhouette means you haven‚Äôt captured it yet.</p>
      <div id="codexGrid" class="codex-grid"></div>
    </div>
  </section>

  <!-- MYTHICS -->
  <section id="mythic" class="hidden">
    <div class="card">
      <h2>Mythic Items</h2>
      <div id="mythicList" class="list"></div>
    </div>
  </section>

  <!-- SETTINGS -->
  <section id="settings" class="hidden">
    <div class="grid grid-2">
      <div class="card">
        <h2>Capture Rules</h2>
        <div class="row">
          <label class="pill">Confidence: <span id="confVal" class="mono"></span></label>
          <input id="confRange" type="range" min="0.5" max="0.98" step="0.01" />
        </div>
        <p class="muted">We block low-confidence or ‚Äúnone/unknown‚Äù predictions to prevent spamming with walls/humans. Train a ‚Äúnone‚Äù class in Teachable Machine for even tighter control.</p>
      </div>
      <div class="card">
        <h2>Data</h2>
        <div class="row">
          <button id="btnExport" class="ghost">Export Save</button>
          <button id="btnImport" class="ghost">Import Save</button>
          <button id="btnReset" style="background:#3a1b2a;border-color:#5a2942">Hard Reset</button>
        </div>
        <input id="importFile" type="file" accept="application/json" class="hidden" />
        <p class="footer">Offline caching is enabled. First visit needs internet to cache model & images.</p>
      </div>
    </div>
  </section>
</main>

<script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@3.21.0/dist/tf.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@teachablemachine/image@0.8.4/dist/teachablemachine-image.min.js"></script>
<script>
/* =========================================================
   CONFIG + ‚ÄúWHERE DO I PUT MY FILES?‚Äù
   ---------------------------------------------------------
   1) Teachable Machine model goes in: /model_real/
      - model_real/model.json
      - model_real/metadata.json
      - model_real/weights.bin
   2) Your digital art goes in: /digital_images/
      REQUIRED filenames for the current starter set:
      - ladybug.jpeg, squirrel.jpeg, dog.jpeg, cat.jpeg, spider.jpeg, fly.jpeg
      Add more later (e.g. bird.jpeg) and register it in MONSTER_LIBRARY below.

   Tweakable knobs:
========================================================= */
const PATHS = {
  MODEL_DIR: "model_real/",
  DIGITAL_DIR: "digital_images/"
};

// Confidence threshold to accept the Teachable Machine prediction.
// Raise to reduce false positives. We also reject "none"/"unknown" labels.
let CONFIDENCE_THRESHOLD = 0.88;

// Rarity chances for captures (monster rarity, not item rarity)
const RARITY_TABLE = [
  { key:"common",   pct: 0.74 },
  { key:"uncommon", pct: 0.25 },
  { key:"rare",     pct: 0.01 }
];

// Loot tables (wild/mini/boss). Mythic item chances included here.
const LOOT_TABLES = {
  wild: [
    { id:"shard_common",   name:"Common Shard",   qty:[1,2],  pct:0.60 },
    { id:"potion_small",   name:"Small Potion",   qty:[1,1],  pct:0.25 },
    { id:"mythic_dust",    name:"Mythic Dust",    qty:[1,1],  pct:0.001 }, // 0.1%
  ],
  mini: [
    { id:"shard_uncommon", name:"Uncommon Shard", qty:[1,3],  pct:0.55 },
    { id:"potion_medium",  name:"Medium Potion",  qty:[1,2],  pct:0.35 },
    { id:"boss_tooth",     name:"Boss Tooth",     qty:[1,1],  pct:0.05 },
    { id:"mythic_dust",    name:"Mythic Dust",    qty:[1,1],  pct:0.0005 }, // 0.05%
  ],
  boss: [
    { id:"shard_rare",     name:"Rare Shard",     qty:[2,4],  pct:0.70 },
    { id:"potion_large",   name:"Large Potion",   qty:[1,2],  pct:0.35 },
    { id:"boss_horn",      name:"Boss Horn",      qty:[1,1],  pct:0.20 }, // unique
    { id:"mythic_core",    name:"Mythic Core",    qty:[1,1],  pct:0.0002 } // 0.02%
  ]
};

// Base stat templates per element/class combo (simple, expandable)
const BASES = {
  // element: { hp, atk, def, spd, stam }
  earth:   { hp: 80, atk:50, def:60, spd:40, stam:60 },
  nature:  { hp: 75, atk:45, def:55, spd:65, stam:70 },
  shadow:  { hp: 60, atk:70, def:40, spd:85, stam:55 },
  light:   { hp: 85, atk:50, def:70, spd:35, stam:65 },
  poison:  { hp: 70, atk:55, def:45, spd:60, stam:65 },
  air:     { hp: 55, atk:45, def:40, spd:95, stam:80 }
};
const CLASS_MOD = {
  Guardian: { hp:+12, def:+10, atk:+0,  spd:-5, stam:+5 },
  Tank:     { hp:+18, def:+8,  atk:-4,  spd:-8, stam:+6 },
  Brawler:  { hp:+6,  def:+2,  atk:+12, spd:+0, stam:+2 },
  Assassin: { hp:-10, def:-5,  atk:+16, spd:+12,stam:-4 },
  Trapper:  { hp:+0,  def:+4,  atk:+6,  spd:+2, stam:+6 },
  Scout:    { hp:-6,  def:-4,  atk:+0,  spd:+16,stam:+10 }
};
const RARITY_MOD = {
  common:   { hp:+0,  atk:+0,  def:+0,  spd:+0,  stam:+0 },
  uncommon: { hp:+6,  atk:+5,  def:+5,  spd:+5,  stam:+6 },
  rare:     { hp:+12, atk:+10, def:+10, spd:+10, stam:+12 },
  boss:     { hp:+30, atk:+24, def:+24, spd:+10, stam:+20 }
};

// Library: where you **add new monsters** (one line per animal).
// key = TeachableMachine className (lowercase), img = digital_images/*.jpeg
// element & mclass drive stats/theme. codexName is the pretty name.
const MONSTER_LIBRARY = {
  ladybug: { img:"ladybug.jpeg",  element:"light",  mclass:"Tank",     codexName:"Guardian Ladybug" },
  squirrel:{ img:"squirrel.jpeg", element:"nature", mclass:"Tank",     codexName:"Barkshield Squirrel" },
  dog:     { img:"dog.jpeg",      element:"earth",  mclass:"Brawler",  codexName:"Ward Hound" },
  cat:     { img:"cat.jpeg",      element:"shadow", mclass:"Assassin", codexName:"Night Prowler" },
  spider:  { img:"spider.jpeg",   element:"poison", mclass:"Trapper",  codexName:"Weave Widow" },
  fly:     { img:"fly.jpeg",      element:"air",    mclass:"Scout",    codexName:"Pest Gale" }
};
// Unknown fallback (when label is ‚Äúnone/unknown‚Äù), still a valid enemy for battles.
const WILD_UNKNOWN = { img:null, element:"nature", mclass:"Brawler", codexName:"Wild Beast" };

// Team limits and evolve gates
const TEAM_SIZE = 3;
const EVO_MAX = 5;
const EVO_GATES = [10, 20, 30, 40, 50]; // level required for each evolution tier

// ================== STATE (localStorage) ==================
const store = {
  get(){ try{return JSON.parse(localStorage.getItem("mt_save")||"{}")}catch{ return {} } },
  set(obj){ localStorage.setItem("mt_save", JSON.stringify(obj)); },
  reset(){ localStorage.removeItem("mt_save"); }
};
let state = {
  monsters: [],     // array of monster objects
  inventory: {},    // { itemId: qty }
  mythics: {},      // { itemId: qty } (also mirrored in inventory)
  team: [],         // array of monster ids (TEAM_SIZE)
  codex: {},        // discovered by key (className)
  kills: { wild:0, mini:0, boss:0 },
  settings: { conf: CONFIDENCE_THRESHOLD }
};
function loadState(){
  const s = store.get();
  state = Object.assign(state, s);
  if(state.settings?.conf){ CONFIDENCE_THRESHOLD = state.settings.conf; }
}
function saveState(){
  state.settings.conf = CONFIDENCE_THRESHOLD;
  store.set(state);
}

// ================== UTILS ==================
function uid(){ return "m-"+Math.random().toString(36).slice(2)+Date.now().toString(36); }
function clamp(v,a,b){ return Math.max(a, Math.min(b,v)); }
function roll(p){ return Math.random() < p; }
function pickRarity(){
  let r=Math.random(), acc=0;
  for(const t of RARITY_TABLE){ acc+=t.pct; if(r<acc) return t.key; }
  return "common";
}
function rarityClass(r){ return "rarity-"+r; }
function outlineClass(r){
  return r==="common"?"outline-common":
         r==="uncommon"?"outline-uncommon":
         r==="rare"?"outline-rare":
         r==="boss"?"outline-boss":"outline-mythic";
}
function fmtPct(p){ return Math.round(p*1000)/10+"%"; }
function randInt(min,max){ return Math.floor(Math.random()*(max-min+1))+min; }
function between([a,b]){ return randInt(a,b); }
function sumLoot(table){
  const drops=[];
  for(const d of table){
    if(roll(d.pct)){
      const qty = between(d.qty);
      drops.push({id:d.id, name:d.name, qty});
    }
  }
  return drops;
}
async function sha256FromCanvas(canvas){
  const blob = await new Promise(r=>canvas.toBlob(r,"image/jpeg",0.92));
  const buf = await blob.arrayBuffer();
  const hashBuffer = await crypto.subtle.digest("SHA-256", buf);
  const hashArray = Array.from(new Uint8Array(hashBuffer));
  return hashArray.map(b=>b.toString(16).padStart(2,"0")).join("");
}

// ================== CAMERA / MODEL ==================
let model=null, metadata=null, stream=null, useRear=true;

async function ensureModel(){
  if(model) return;
  // quick presence check (helps debug 404)
  for(const f of ["model.json","metadata.json","weights.bin"]){
    try{
      const res = await fetch(PATHS.MODEL_DIR+f,{cache:"no-store"});
      if(!res.ok){ throw new Error(`Model file missing: ${f} (HTTP ${res.status})`); }
    }catch(e){ throw new Error(`Failed to fetch ${f}: ${e.message}`); }
  }
  model = await tmImage.load(PATHS.MODEL_DIR+"model.json", PATHS.MODEL_DIR+"metadata.json");
  // @ts-ignore
  metadata = model?.getTotalClasses ? {totalClasses:model.getTotalClasses()} : {};
}

async function startCamera(){
  stopCamera();
  const constraints = {
    video: {
      facingMode: useRear ? {ideal:"environment"} : "user",
      width:{ideal:1280}, height:{ideal:720}
    },
    audio:false
  };
  try{
    stream = await navigator.mediaDevices.getUserMedia(constraints);
    const v = $("#webcam");
    v.srcObject = stream;
    $("#camStatus").textContent = useRear?"Rear camera":"Front camera";
    $("#btnCapture").disabled = false;
    $("#btnRetake").disabled = true;
    $("#errorBox").textContent = "";
  }catch(err){
    $("#errorBox").textContent = `Camera error: ${err.name} ‚Äî ${err.message}`;
    $("#btnCapture").disabled = true;
  }
}
function stopCamera(){
  if(stream){ stream.getTracks().forEach(t=>t.stop()); stream=null; }
}
function $ (s){ return document.querySelector(s); }
function el(tag, attrs={}, children=[]){
  const n = document.createElement(tag);
  Object.entries(attrs).forEach(([k,v])=>{
    if(k==="class") n.className=v;
    else if(k==="html") n.innerHTML=v;
    else n.setAttribute(k,v);
  });
  children.forEach(c=>n.appendChild(c));
  return n;
}

// ================== STATS & MONSTER CREATION ==================
function computeStats(element, mclass, rarity, level=1){
  const base = {...BASES[element]};
  const modc = CLASS_MOD[mclass]||{hp:0,atk:0,def:0,spd:0,stam:0};
  const modr = RARITY_MOD[rarity]||{hp:0,atk:0,def:0,spd:0,stam:0};
  let hp=base.hp+modc.hp+modr.hp, atk=base.atk+modc.atk+modr.atk, def=base.def+modc.def+modr.def, spd=base.spd+modc.spd+modr.spd, stam=base.stam+modc.stam+modr.stam;
  // scale with level (simple: +2% per level)
  const mult = 1+(Math.max(level-1,0)*0.02);
  return {
    hp: Math.round(hp*mult),
    atk: Math.round(atk*mult),
    def: Math.round(def*mult),
    spd: Math.round(spd*mult),
    stam: Math.round(stam*mult)
  };
}
function makeMonsterFromLabel(label, conf, imgHash){
  const key = (label||"").toLowerCase();
  const lib = MONSTER_LIBRARY[key];
  if(!lib) return null;
  const rarity = pickRarity();
  const level = 1;
  const evo = 0;
  const stats = computeStats(lib.element, lib.mclass, rarity, level);
  const id = uid();
  const mon = {
    id, key, name: lib.codexName, element: lib.element, mclass: lib.mclass,
    rarity, level, evo, exp:0, stats, currentHP:stats.hp, stam:stats.stam,
    img: PATHS.DIGITAL_DIR+lib.img, hash: imgHash, seen: Date.now()
  };
  return mon;
}
function renderBars(hp, hpMax, stam, stamMax){
  const hpPct = clamp(Math.round(hp/hpMax*100),0,100);
  const stPct = clamp(Math.round(stam/stamMax*100),0,100);
  return `
    <div>
      <div class="row" style="justify-content:space-between;margin-bottom:4px"><span>HP</span><span class="mono">${hp}/${hpMax}</span></div>
      <div class="bar"><span class="hp" style="width:${hpPct}%"></span></div>
    </div>
    <div>
      <div class="row" style="justify-content:space-between;margin-bottom:4px"><span>Stamina</span><span class="mono">${stPct}/${stamMax}</span></div>
      <div class="bar"><span class="stam" style="width:${stPct}%"></span></div>
    </div>
  `;
}
function monsterCard(mon){
  const rclass = rarityClass(mon.rarity);
  const oclass = outlineClass(mon.rarity);
  return `
    <div class="card ${oclass}">
      <div class="row" style="justify-content:space-between">
        <div>
          <div class="${rclass}" style="font-weight:700">${mon.name}</div>
          <div class="muted">${mon.element.toUpperCase()} ‚Ä¢ ${mon.mclass} ‚Ä¢ Lv ${mon.level} ‚Ä¢ Evo ${mon.evo}</div>
        </div>
        <div class="pill mono">ID: ${mon.id}</div>
      </div>
      <img class="preview glow" src="${mon.img}" alt="${mon.name}">
      <div class="stats">
        ${renderBars(mon.currentHP, mon.stats.hp, mon.stam, mon.stats.stam)}
      </div>
      <div class="row" style="justify-content:space-between;margin-top:8px">
        <div class="muted">ATK <span class="mono">${mon.stats.atk}</span> ‚Ä¢ DEF <span class="mono">${mon.stats.def}</span> ‚Ä¢ SPD <span class="mono">${mon.stats.spd}</span></div>
        <div class="row">
          <button class="btnAddTeam" data-id="${mon.id}">Add to Team</button>
          <button class="btnBreak" data-id="${mon.id}">Break ‚Üí Shards</button>
        </div>
      </div>
    </div>
  `;
}

// ================== INVENTORY, TEAM, SHARDS, EVOLVE ==================
function addInventory(itemId, name, qty){
  state.inventory[itemId] = (state.inventory[itemId]||0)+qty;
  // Track mythics separately for the Mythic tab (also in inventory)
  if(itemId.startsWith("mythic")) state.mythics[itemId] = (state.mythics[itemId]||0)+qty;
  saveState();
}
function animateFly(text, fromEl){
  const r = fromEl.getBoundingClientRect();
  const el = el("div",{class:"fly", html:text});
  el.style.left = r.left+"px";
  el.style.top = r.top+"px";
  el.style.opacity = "1";
  document.body.appendChild(el);
  const inv = $("#tabs .tab[data-tab='inventory']").getBoundingClientRect();
  requestAnimationFrame(()=>{
    el.style.transform = `translate(${inv.left-r.left}px, ${inv.top-r.top}px) scale(0.6)`;
    el.style.opacity = "0";
  });
  setTimeout(()=>el.remove(),900);
}
function breakIntoShards(mon){
  const tier = mon.rarity==="rare" ? "rare" : mon.rarity==="uncommon" ? "uncommon" : "common";
  const qty = mon.rarity==="rare"? between([6,10]) : mon.rarity==="uncommon"? between([3,6]) : between([1,3]);
  addInventory(`shard_${tier}`, `${tier} shard`, qty);
}
function canEvolve(mon){
  if(mon.evo>=EVO_MAX) return false;
  const needLevel = EVO_GATES[mon.evo]||999;
  const shardType = mon.rarity==="rare"?"shard_rare":mon.rarity==="uncommon"?"shard_uncommon":"shard_common";
  const needShards = 3+mon.evo*2; // scales by evo tier
  const has = state.inventory[shardType]||0;
  return mon.level>=needLevel && has>=needShards;
}
function evolve(mon){
  if(!canEvolve(mon)) return false;
  const shardType = mon.rarity==="rare"?"shard_rare":mon.rarity==="uncommon"?"shard_uncommon":"shard_common";
  const cost = 3+mon.evo*2;
  state.inventory[shardType] = (state.inventory[shardType]||0)-cost;
  mon.evo++;
  // big stat bump per evolution (10% total scala)
  const mult = 1+mon.evo*0.10;
  const newStats = computeStats(mon.element, mon.mclass, mon.rarity, mon.level);
  mon.stats = {
    hp: Math.round(newStats.hp*mult),
    atk: Math.round(newStats.atk*mult),
    def: Math.round(newStats.def*mult),
    spd: Math.round(newStats.spd*mult),
    stam: Math.round(newStats.stam*mult)
  };
  mon.currentHP = mon.stats.hp;
  mon.stam = mon.stats.stam;
  saveState();
  return true;
}
function addMonster(mon){
  state.monsters.push(mon);
  state.codex[mon.key]=true;
  saveState();
}
function getMonster(id){ return state.monsters.find(m=>m.id===id); }
function removeMonster(id){
  state.monsters = state.monsters.filter(m=>m.id!==id);
  state.team = state.team.filter(t=>t!==id);
  saveState();
}

// ================== BATTLES ==================
function enemyFrom(keyOrUnknown, tier){ // tier: 'wild' | 'mini' | 'boss'
  if(tier==="wild"){
    // 85% real monster library, 15% unknown beast
    const keys = Object.keys(MONSTER_LIBRARY);
    const pickUnknown = Math.random()<0.15;
    if(pickUnknown) return buildEnemy("wild", WILD_UNKNOWN, "common");
    const k = keys[Math.floor(Math.random()*keys.length)];
    return buildEnemy("wild", MONSTER_LIBRARY[k], "common");
  }else if(tier==="mini"){
    const keys = Object.keys(MONSTER_LIBRARY);
    const k = keys[Math.floor(Math.random()*keys.length)];
    return buildEnemy("mini", MONSTER_LIBRARY[k], "uncommon");
  }else{ // boss
    const keys = Object.keys(MONSTER_LIBRARY);
    const k = keys[Math.floor(Math.random()*keys.length)];
    return buildEnemy("boss", MONSTER_LIBRARY[k], "boss");
  }
}
function buildEnemy(type, lib, rarity){
  // bosses tougher (lvl 20-35), mini (10-20), wild (3-10)
  const lvl = type==="boss" ? between([20,35]) : type==="mini" ? between([10,20]) : between([3,10]);
  const name = lib.codexName || "Wild Beast";
  const img = lib.img ? PATHS.DIGITAL_DIR + lib.img : "";
  const element = lib.element || "nature";
  const mclass = lib.mclass || "Brawler";
  const stats = computeStats(element, mclass, rarity, lvl);
  return { type, name, element, mclass, img, rarity, level:lvl, stats, hp:stats.hp, stam:stats.stam };
}
function teamPower(){
  const ids = state.team.slice(0,TEAM_SIZE);
  const mons = ids.map(getMonster).filter(Boolean);
  let total = { atk:0, def:0, spd:0, hp:0 };
  mons.forEach(m=>{
    total.atk+=m.stats.atk; total.def+=m.stats.def; total.spd+=m.stats.spd; total.hp+=m.stats.hp;
  });
  return { mons, total };
}
function simulateBattle(tier){ // simple auto resolver
  const enemy = enemyFrom(null, tier);
  const { mons, total } = teamPower();
  if(mons.length===0){ return { ok:false, msg:"No team selected."}; }
  // Compute win chance: compare (team atk+def+spd) vs (enemy stats)
  const teamScore = total.atk*1.0 + total.def*0.9 + total.spd*0.6;
  const enemyScore = enemy.stats.atk*1.1 + enemy.stats.def*1.0 + enemy.stats.spd*0.7 + (enemy.level*2);
  let baseWin = teamScore / (teamScore + enemyScore);
  // Guarantee rough goals: boss ~7% win (as requested), mini moderate, wild decent
  if(tier==="boss") baseWin = Math.min(baseWin, 0.07);
  if(tier==="mini") baseWin = Math.min(Math.max(baseWin,0.25), 0.55);
  if(tier==="wild") baseWin = Math.min(Math.max(baseWin,0.55), 0.85);

  const win = Math.random() < baseWin;
  const drops = sumLoot(LOOT_TABLES[tier]);
  return { ok:true, win, enemy, drops, baseWin };
}

// ================== UI RENDERERS ==================
function drawInventory(){
  const box = $("#invList"); box.innerHTML="";
  const entries = Object.entries(state.inventory);
  if(entries.length===0){ box.innerHTML = `<div class="muted">Empty.</div>`; return;}
  for(const [id,qty] of entries){
    const row = el("div",{class:"item"},[
      el("div",{html:`<strong>${id}</strong>`}),
      el("div",{html:`x <span class="mono">${qty}</span>`})
    ]);
    box.appendChild(row);
  }
  drawKillCounts();
}
function drawTeam(){
  const slots = $("#teamSlots"); slots.innerHTML="";
  for(let i=0;i<TEAM_SIZE;i++){
    const id = state.team[i];
    const mon = id ? getMonster(id) : null;
    const wrap = el("div",{class:"item"});
    if(mon){
      wrap.innerHTML = `
        <div>
          <div><strong>${mon.name}</strong> <span class="${rarityClass(mon.rarity)}">${mon.rarity.toUpperCase()}</span></div>
          <div class="muted">${mon.element} ‚Ä¢ ${mon.mclass} ‚Ä¢ Lv ${mon.level} ‚Ä¢ Evo ${mon.evo}</div>
        </div>
        <div class="row">
          <button class="btnRemoveSlot" data-idx="${i}">Remove</button>
          <button class="btnEvolve" data-id="${mon.id}">Evolve</button>
        </div>
      `;
    }else{
      wrap.innerHTML = `<div class="muted">Empty slot</div>`;
    }
    slots.appendChild(wrap);
  }
}
function drawMonsters(){
  const list = $("#monsterList"); list.innerHTML="";
  if(state.monsters.length===0){ list.innerHTML = `<div class="muted">No monsters yet.</div>`; return;}
  state.monsters.forEach(m=>{
    const row = el("div",{class:"item"});
    row.innerHTML = `
      <div>
        <div><strong>${m.name}</strong> <span class="${rarityClass(m.rarity)}">${m.rarity.toUpperCase()}</span></div>
        <div class="muted">${m.element} ‚Ä¢ ${m.mclass} ‚Ä¢ Lv ${m.level} ‚Ä¢ Evo ${m.evo}</div>
      </div>
      <div class="row">
        <button class="btnAddTeam" data-id="${m.id}">Add to Team</button>
        <button class="btnBreak" data-id="${m.id}">Break</button>
      </div>
    `;
    list.appendChild(row);
  });
}
function drawCodex(){
  const grid = $("#codexGrid"); grid.innerHTML="";
  const keys = Object.keys(MONSTER_LIBRARY);
  keys.forEach(k=>{
    const lib = MONSTER_LIBRARY[k];
    const known = !!state.codex[k];
    const card = el("div",{class:"codex-card"});
    card.innerHTML = `
      <img src="${PATHS.DIGITAL_DIR+lib.img}" class="${known?"":"silhouette"}" alt="${lib.codexName}">
      <div style="margin-top:6px"><strong>${lib.codexName}</strong></div>
      <div class="muted">${k}</div>
    `;
    grid.appendChild(card);
  });
}
function drawMythics(){
  const box = $("#mythicList"); box.innerHTML="";
  const entries = Object.entries(state.mythics);
  if(entries.length===0){ box.innerHTML = `<div class="muted">No mythic items yet.</div>`; return; }
  for(const [id,qty] of entries){
    const row = el("div",{class:"item"},[
      el("div",{html:`<strong>${id}</strong>`}),
      el("div",{html:`x <span class="mono">${qty}</span>`})
    ]);
    box.appendChild(row);
  }
}
function drawKillCounts(){
  const box = $("#killCounts"); box.innerHTML="";
  const rows = [
    ["Wild", state.kills.wild],
    ["Mini-Boss", state.kills.mini],
    ["Boss", state.kills.boss]
  ];
  rows.forEach(([name,val])=>{
    const r = el("div",{class:"item"},[
      el("div",{html:`<strong>${name}</strong>`}),
      el("div",{html:`<span class="mono">${val}</span>`})
    ]);
    box.appendChild(r);
  });
}
function renderSettings(){
  $("#confRange").value = String(CONFIDENCE_THRESHOLD);
  $("#confVal").textContent = String(CONFIDENCE_THRESHOLD);
}

// ================== TABS ==================
document.querySelectorAll(".tab").forEach(t=>{
  t.addEventListener("click",()=>{
    document.querySelectorAll(".tab").forEach(n=>n.classList.remove("active"));
    t.classList.add("active");
    const name = t.getAttribute("data-tab");
    document.querySelectorAll("main>section").forEach(s=>s.classList.add("hidden"));
    $("#"+name).classList.remove("hidden");
  });
});

// ================== CAPTURE FLOW ==================
$("#btnStart").addEventListener("click", async ()=>{
  await startCamera();
});
$("#btnFlip").addEventListener("click", async ()=>{
  useRear = !useRear;
  await startCamera();
});
$("#btnRetake").addEventListener("click", async ()=>{
  $("#resultBox").innerHTML = "Retake ready.";
  await startCamera();
});

$("#fileInput").addEventListener("change", async (e)=>{
  const file = e.target.files[0];
  if(!file) return;
  const img = new Image();
  img.onload = async ()=>{
    const c = $("#frame"); const ctx = c.getContext("2d");
    c.width = img.width; c.height = img.height; ctx.drawImage(img,0,0);
    await handlePredictionFromCanvas(c);
  };
  img.src = URL.createObjectURL(file);
});

$("#btnCapture").addEventListener("click", async ()=>{
  const v = $("#webcam");
  if(!stream || !v.videoWidth){ $("#errorBox").textContent = "No webcam stream available."; return; }
  const c = $("#frame"); const ctx = c.getContext("2d");
  c.width = v.videoWidth; c.height = v.videoHeight; ctx.drawImage(v,0,0);
  // Freeze camera till retake
  stopCamera();
  $("#btnCapture").disabled = true;
  $("#btnRetake").disabled = false;
  await handlePredictionFromCanvas(c);
});

async function handlePredictionFromCanvas(canvas){
  $("#errorBox").textContent = "";
  $("#resultBox").innerHTML = `<div class="muted">Classifying...</div>`;
  try{
    await ensureModel();
    const preds = await model.predict(canvas);
    preds.sort((a,b)=>b.probability-a.probability);
    const top = preds[0];
    const label = (top.className||"").toLowerCase();
    const conf  = top.probability||0;

    // Reject if low confidence or explicitly none/unknown class
    if(conf < CONFIDENCE_THRESHOLD || label==="none" || label==="unknown"){
      $("#resultBox").innerHTML = `
        <div class="card">
          <div class="row" style="justify-content:space-between">
            <strong>Rejected</strong>
            <span class="pill mono">conf=${(conf*100).toFixed(1)}%</span>
          </div>
          <div class="muted">Low confidence or ‚Äúnone/unknown‚Äù. Try a clearer shot of a supported animal class.</div>
        </div>`;
      return;
    }

    // Duplicate prevention by image hash
    const imgHash = await sha256FromCanvas(canvas);
    const dup = state.monsters.find(m=>m.hash===imgHash);
    if(dup){
      $("#resultBox").innerHTML = `
        <div class="card">
          <strong>Duplicate photo detected</strong>
          <div class="muted">This image was used to create <span class="mono">${dup.name}</span>. Try a new angle or subject.</div>
        </div>`;
      return;
    }

    const mon = makeMonsterFromLabel(label, conf, imgHash);
    if(!mon){
      // Unknown class ‚Äî don‚Äôt create a monster card, but we can show Wild Beast ‚Äútease‚Äù
      $("#resultBox").innerHTML = `
        <div class="card">
          <div class="row" style="justify-content:space-between">
            <strong>No matching monster</strong>
            <span class="pill mono">conf=${(conf*100).toFixed(1)}%</span>
          </div>
          <div class="muted">Your model class <span class="mono">${label}</span> isn‚Äôt registered yet in MONSTER_LIBRARY.</div>
        </div>`;
      return;
    }

    addMonster(mon);
    // Show card
    $("#resultBox").innerHTML = monsterCard(mon);
    // Small glow on rarity
    $("#resultBox .card").classList.add("glow");

    // Loot a tiny chance even on capture to keep excitement
    if(roll(0.12)){
      const bonus = [{id:"potion_small", name:"Small Potion", qty:1}];
      grantLoot(bonus, $("#resultBox .card"));
    }

    // Wire buttons on the newly rendered card
    wireDynamicButtons();
    // Refresh other views
    drawMonsters(); drawTeam(); drawCodex(); drawInventory();
  }catch(err){
    $("#resultBox").innerHTML = `<div class="muted">Error: ${err.message}</div>`;
  }
}

// ================== DYNAMIC BUTTONS (delegated) ==================
function wireDynamicButtons(){
  document.querySelectorAll(".btnAddTeam").forEach(b=>{
    b.onclick = ()=>{
      const id = b.getAttribute("data-id");
      if(state.team.includes(id)) return;
      if(state.team.length>=TEAM_SIZE){ alert("Team full. Remove a slot first."); return; }
      state.team.push(id); saveState(); drawTeam();
    };
  });
  document.querySelectorAll(".btnBreak").forEach(b=>{
    b.onclick = ()=>{
      const id = b.getAttribute("data-id");
      const mon = getMonster(id); if(!mon) return;
      if(confirm(`Break ${mon.name} into shards? This cannot be undone.`)){
        breakIntoShards(mon);
        removeMonster(id);
        drawInventory(); drawMonsters(); drawTeam();
      }
    };
  });
  document.querySelectorAll(".btnRemoveSlot").forEach(b=>{
    b.onclick = ()=>{
      const idx = +b.getAttribute("data-idx");
      state.team.splice(idx,1); saveState(); drawTeam();
    };
  });
  document.querySelectorAll(".btnEvolve").forEach(b=>{
    b.onclick = ()=>{
      const id = b.getAttribute("data-id");
      const mon = getMonster(id); if(!mon) return;
      if(!canEvolve(mon)){
        alert("Requirements not met: need level gate + shards.");
        return;
      }
      evolve(mon);
      drawTeam(); drawMonsters(); drawInventory();
    };
  });
}

// ================== BATTLE WIRES ==================
$("#btnWild").addEventListener("click",()=>startBattle("wild"));
$("#btnMini").addEventListener("click",()=>startBattle("mini"));
$("#btnBoss").addEventListener("click",()=>startBattle("boss"));

function startBattle(tier){
  const res = simulateBattle(tier);
  const box = $("#battleView");
  if(!res.ok){ box.innerHTML = `<div class="muted">${res.msg}</div>`; return; }
  const enemy = res.enemy;
  // Outcome
  const header = `
    <div class="row" style="justify-content:space-between;align-items:flex-start">
      <div>
        <div><strong>${enemy.name}</strong> <span class="${rarityClass(enemy.rarity)}">${enemy.rarity.toUpperCase()}</span></div>
        <div class="muted">${enemy.element} ‚Ä¢ ${enemy.mclass} ‚Ä¢ Lv ${enemy.level}</div>
      </div>
      <div class="pill mono">Win chance ~ ${Math.round(res.baseWin*100)}%</div>
    </div>
  `;
  const art = enemy.img? `<img class="preview ${outlineClass(enemy.rarity)}" src="${enemy.img}" alt="${enemy.name}">`
                       : `<div class="preview" style="height:180px;display:flex;align-items:center;justify-content:center;border:1px dashed #2a325e">Silhouette</div>`;
  const resultTxt = res.win ? `<span style="color:${getComputedStyle(document.documentElement).getPropertyValue('--good')}">Victory!</span>` :
                              `<span style="color:${getComputedStyle(document.documentElement).getPropertyValue('--bad')}">Defeat</span>`;
  const drops = res.win ? res.drops : [];
  box.innerHTML = `
    <div class="card">
      ${header}
      ${art}
      <div class="row" style="justify-content:space-between;margin-top:8px">
        <div><strong>Result:</strong> ${resultTxt}</div>
        <div class="muted">HP ${enemy.stats.hp} ‚Ä¢ ATK ${enemy.stats.atk} ‚Ä¢ DEF ${enemy.stats.def} ‚Ä¢ SPD ${enemy.stats.spd}</div>
      </div>
      <div id="dropZone"></div>
    </div>
  `;
  // tally kills
  if(res.win){
    if(enemy.type==="boss") state.kills.boss++; else if(enemy.type==="mini") state.kills.mini++; else state.kills.wild++;
    // Loot fly-to-inventory animation
    if(drops.length){
      const dz = $("#dropZone");
      dz.innerHTML = `<div style="margin-top:8px"><strong>Loot</strong></div>`;
      drops.forEach(d=>{
        const chip = el("div",{class:"pill", html:`${d.name} x${d.qty}`});
        dz.appendChild(chip);
        // add + animate
        addInventory(d.id, d.name, d.qty);
        animateFly(`+${d.qty} ${d.name}`, chip);
      });
      drawInventory();
    }
    // Quick XP for team on win
    state.team.forEach(id=>{
      const m = getMonster(id); if(!m) return;
      m.exp += enemy.type==="boss"? 45 : enemy.type==="mini"? 25 : 12;
      // level-up: need exp >= level*20
      while(m.exp >= m.level*20){
        m.exp -= m.level*20;
        m.level++;
        // Recompute stats on level up
        m.stats = computeStats(m.element, m.mclass, m.rarity, m.level);
        m.currentHP = m.stats.hp; m.stam = m.stats.stam;
      }
    });
  }
  saveState();
  drawKillCounts();
  drawTeam();
}

// ================== SETTINGS & DATA WIRES ==================
$("#confRange").addEventListener("input",(e)=>{
  CONFIDENCE_THRESHOLD = +e.target.value;
  $("#confVal").textContent = String(CONFIDENCE_THRESHOLD);
  saveState();
});
$("#btnReset").addEventListener("click",()=>{
  if(confirm("Reset all local data? This cannot be undone.")){
    store.reset(); loadState();
    drawInventory(); drawTeam(); drawMonsters(); drawCodex(); drawKillCounts(); renderSettings();
  }
});
$("#btnExport").addEventListener("click",()=>{
  const data = JSON.stringify(state,null,2);
  const blob = new Blob([data],{type:"application/json"});
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.href=url; a.download="monster_transform_save.json"; a.click();
  URL.revokeObjectURL(url);
});
$("#btnImport").addEventListener("click",()=>$("#importFile").click());
$("#importFile").addEventListener("change",async (e)=>{
  const file = e.target.files[0]; if(!file) return;
  const text = await file.text();
  try{
    const data = JSON.parse(text);
    store.set(data); loadState();
    drawInventory(); drawTeam(); drawMonsters(); drawCodex(); drawKillCounts(); renderSettings();
    alert("Save imported.");
  }catch{ alert("Invalid save file."); }
});

// ================== SERVICE WORKER (offline runtime cache) ==================
(async function registerSW(){
  if(!("serviceWorker" in navigator)) return;
  const swCode = `
  const CNAME="mt-cache-v1";
  self.addEventListener("install",e=>{ self.skipWaiting(); });
  self.addEventListener("activate",e=>{ e.waitUntil(caches.keys().then(keys=>Promise.all(keys.filter(k=>k!==CNAME).map(k=>caches.delete(k))))); self.clients.claim(); });
  self.addEventListener("fetch",e=>{
    const req=e.request;
    // Runtime cache-first for model and images
    if(req.url.includes("/model_real/") || req.url.includes("/digital_images/") || req.destination==="image"){
      e.respondWith(caches.open(CNAME).then(async cache=>{
        const hit = await cache.match(req); if(hit) return hit;
        try{ const res = await fetch(req); cache.put(req,res.clone()); return res; }catch(err){ return hit || Response.error(); }
      }));
    }
  });`;
  const blob = new Blob([swCode],{type:"text/javascript"});
  const url = URL.createObjectURL(blob);
  try{ await navigator.serviceWorker.register(url); }catch{}
})();

// ================== INIT ==================
function initUI(){
  loadState();
  renderSettings();
  $("#confVal").textContent = String(CONFIDENCE_THRESHOLD);
  drawInventory(); drawTeam(); drawMonsters(); drawCodex(); drawKillCounts(); drawMythics();
  wireDynamicButtons();
}
document.addEventListener("visibilitychange",()=>{ if(document.hidden) stopCamera(); });

initUI();
</script>
</body>
</html>  .stack{display:flex;gap:8px;flex-wrap:wrap}
  .statbar{height:12px;background:#2a2a2a;border:1px solid #333;border-radius:999px;overflow:hidden}
  .statbar>.fill{height:100%}
  .hp{background:#d32f2f}.stam{background:#43a047}
  .center{display:flex;align-items:center;justify-content:center}

  /* Monster card */
  .card{background:var(--soft);border:1px solid #2b2f35;border-radius:16px;padding:12px;display:grid;gap:10px;position:relative;overflow:hidden}
  .card .title{display:flex;justify-content:space-between;align-items:center}
  .rarity{font-weight:700}
  .rarity.common{color:var(--c-common)}
  .rarity.uncommon{color:var(--c-uncommon)}
  .rarity.rare{color:var(--c-rare)}
  .rarity.epic{color:var(--c-epic)}
  .rarity.legendary{color:var(--c-legend)}
  .rarity.mythic{color:var(--c-mythic)}
  .glow{position:absolute;inset:-40%;filter:blur(40px);opacity:.20;pointer-events:none}
  .glow.common{background:radial-gradient(var(--c-common),transparent)}
  .glow.uncommon{background:radial-gradient(var(--c-uncommon),transparent)}
  .glow.rare{background:radial-gradient(var(--c-rare),transparent)}
  .glow.epic{background:radial-gradient(var(--c-epic),transparent)}
  .glow.legendary{background:radial-gradient(var(--c-legend),transparent)}
  .glow.mythic{background:radial-gradient(var(--c-mythic),transparent)}
  .card img.art{width:100%;max-height:240px;object-fit:contain;border-radius:10px;border:1px solid #2e2e2e;background:#111}

  .inv-grid{display:grid;grid-template-columns:repeat(auto-fill,minmax(160px,1fr));gap:10px}
  .pill{font-size:12px;border:1px solid #333;background:#1f2327;padding:4px 8px;border-radius:999px}
  .badge{font-size:11px;padding:3px 6px;border-radius:6px;border:1px solid #333;background:#1f2327}
  .badge.common{color:var(--c-common)} .badge.uncommon{color:var(--c-uncommon)} .badge.rare{color:var(--c-rare)}
  .badge.epic{color:var(--c-epic)} .badge.legendary{color:var(--c-legend)} .badge.mythic{color:var(--c-mythic)}

  #inventoryAnchor{position:fixed;right:12px;top:10px; width:28px;height:28px;border-radius:8px;border:1px solid #2b2f35;background:#1d2126;
    display:flex;align-items:center;justify-content:center;z-index:10}
  .fly{position:fixed;pointer-events:none;transition:transform .9s ease-in, opacity .9s ease-in}

  .muted{color:var(--muted);font-size:13px}
  .sep{height:1px;background:#242a31;margin:8px 0}
  .error{color:#ff8a80}

  /* Modal (victory/defeat/boss) */
  .modal{position:fixed;inset:0;background:rgba(0,0,0,.65);display:none;align-items:center;justify-content:center;z-index:50}
  .modal .box{background:#13161a;border:1px solid #2b2f35;border-radius:18px;padding:16px;max-width:820px;width:92%}
  .modal h2{margin-top:0}
</style>
</head>
<body>

<header>
  <h1>Monster Transform ‚Äî PvPvE Beta</h1>
  <div class="stack" id="tabs">
    <button class="tab-btn active" data-tab="capture">Capture</button>
    <button class="tab-btn" data-tab="inventory">Inventory</button>
    <button class="tab-btn" data-tab="team">Team</button>
    <button class="tab-btn" data-tab="battle">Battle</button>
    <button class="tab-btn" data-tab="loot">Loot</button>
    <button class="tab-btn" data-tab="mythics">Mythics</button>
  </div>
  <div id="inventoryAnchor" title="Inventory">üéí</div>
</header>

<main>
  <!-- CAPTURE -->
  <section class="panel" id="tab-capture">
    <div class="row">
      <div class="col">
        <div class="stack">
          <button class="btn primary" id="startCamBtn">‚ñ∂ Start Camera</button>
          <button class="btn" id="flipBtn">üîÅ Flip</button>
          <button class="btn ghost" id="uploadBtn">üìÅ Upload</button>
        </div>
        <p class="muted">iOS requires HTTPS (e.g., GitHub Pages). If camera fails, use Upload.</p>
        <video id="webcam" playsinline autoplay muted disablepictureinpicture></video>
        <input type="file" id="fileInput" accept="image/*" capture="environment" hidden />
        <div class="stack">
          <button class="btn good" id="captureBtn">üì∏ Capture & Transform</button>
        </div>
        <canvas id="captureCanvas" style="display:none"></canvas>
        <p id="capErr" class="error"></p>
      </div>

      <div class="col">
        <h3>Result</h3>
        <div id="result"></div>
      </div>
    </div>

    <div class="sep"></div>
    <div>
      <span class="pill">Kill Count: <span id="killCount">0</span></span>
      <span class="pill">Monsters Owned: <span id="ownedCount">0</span></span>
      <span class="pill">Mythics Found: <span id="mythicCount">0</span></span>
    </div>
  </section>

  <!-- INVENTORY -->
  <section class="panel" id="tab-inventory" style="display:none">
    <div class="stack">
      <span class="pill">Capacity: <span id="invUsed">0</span>/<span id="invCap">50</span></span>
      <button class="btn" id="expandInvBtn">+10 Slots (demo)</button>
    </div>
    <div class="sep"></div>
    <div id="inventory" class="inv-grid"></div>
  </section>

  <!-- TEAM -->
  <section class="panel" id="tab-team" style="display:none">
    <p class="muted">Pick up to 3 monsters for your active team. Mark one as your ‚ÄúBest Pal‚Äù for bonuses.</p>
    <div id="team" class="inv-grid"></div>
  </section>

  <!-- BATTLE -->
  <section class="panel" id="tab-battle" style="display:none">
    <div class="stack">
      <button class="btn primary" id="fightWildBtn">‚öîÔ∏è Fight Wild</button>
      <button class="btn warn" id="fightMiniBtn">üëπ Mini-Boss</button>
      <button class="btn bad" id="fightBossBtn">üíÄ Boss</button>
    </div>
    <div class="row">
      <div class="col">
        <h3>Your Team</h3>
        <div id="yourTeam" class="inv-grid"></div>
      </div>
      <div class="col">
        <h3>Enemy</h3>
        <div id="enemyCard"></div>
      </div>
    </div>
    <div class="sep"></div>
    <div id="battleLog" style="white-space:pre-line;min-height:120px"></div>
    <div id="battleLoot" class="stack"></div>
  </section>

  <!-- LOOT -->
  <section class="panel" id="tab-loot" style="display:none">
    <h3>Items</h3>
    <div id="lootList" class="inv-grid"></div>
  </section>

  <!-- MYTHICS -->
  <section class="panel" id="tab-mythics" style="display:none">
    <h3>Mythic & Legendary Finds</h3>
    <div id="mythicList" class="inv-grid"></div>
  </section>
</main>

<!-- Victory/Defeat modal -->
<div class="modal" id="resultModal" aria-hidden="true">
  <div class="box">
    <h2 id="modalTitle">Result</h2>
    <div class="row">
      <div class="col">
        <h3>Your Team</h3>
        <div id="modalTeam" class="inv-grid"></div>
      </div>
      <div class="col">
        <h3>Enemy</h3>
        <div id="modalEnemy"></div>
      </div>
    </div>
    <div class="sep"></div>
    <div id="modalLoot" class="stack"></div>
    <div class="sep"></div>
    <div class="stack">
      <button class="btn good" id="closeModal">Continue</button>
    </div>
  </div>
</div>

<script>
/* =========================
   0) CONSTANTS & TABLES
   ========================= */
const MODEL_URL = "model_real/";
const CONFIDENCE_THRESHOLD = 0.70;
const DUPLICATE_COOLDOWN_MINUTES = 60;
const INVENTORY_CAP_START = 50;
const TEAM_SIZE = 3;
const EVOLVE_MAX = 5;
const EVOLVE_LEVEL_GATES = [10,20,30,40,50];
const BASE_XP_PER_WIN = 25;
const UNKNOWN_NAME = "Wild Beast";

// Rarity roll tables
const RARITY = [
  {key:'mythic',    pct:0.10,  mult:1.9},
  {key:'legendary', pct:0.90,  mult:1.6},
  {key:'epic',      pct:3.00,  mult:1.35},
  {key:'rare',      pct:5.00,  mult:1.18},
  {key:'uncommon',  pct:24.00, mult:1.08},
  {key:'common',    pct:66.99, mult:1.00},
];
const BOSS_RARITY = [
  {key:'mythic',    pct:0.30, mult:1.9},
  {key:'legendary', pct:4.00, mult:1.6},
  {key:'epic',      pct:12.0, mult:1.35},
  {key:'rare',      pct:20.0, mult:1.18},
  {key:'uncommon',  pct:28.0, mult:1.08},
  {key:'common',    pct:35.7, mult:1.00},
];
const MINIBOSS_RARITY = [
  {key:'mythic',    pct:0.15, mult:1.9},
  {key:'legendary', pct:2.00, mult:1.6},
  {key:'epic',      pct:8.0,  mult:1.35},
  {key:'rare',      pct:16.0, mult:1.18},
  {key:'uncommon',  pct:30.0, mult:1.08},
  {key:'common',    pct:43.85, mult:1.00},
];

// Archetypes & elements
const ARCHETYPES = {
  guardian:  {hp:[80,110], atk:[18,28], def:[18,28], spd:[10,16], stamina:[60,90], element:'earth'},
  rogue:     {hp:[60,80],  atk:[24,36], def:[10,18], spd:[20,30], stamina:[50,80], element:'shadow'},
  tank:      {hp:[110,140],atk:[16,26], def:[22,34], spd:[8,12],  stamina:[70,100], element:'light'},
  speedster: {hp:[55,75],  atk:[20,30], def:[10,16], spd:[28,38], stamina:[55,85], element:'nature'},
  plague:    {hp:[65,85],  atk:[18,30], def:[12,18], spd:[24,32], stamina:[55,80], element:'air'},
  trapper:   {hp:[70,95],  atk:[20,28], def:[14,24], spd:[16,22], stamina:[60,85], element:'poison'},
  brawler:   {hp:[75,95],  atk:[22,32], def:[16,22], spd:[14,22], stamina:[60,85], element:'neutral'},
};

// üëâ Add more animals by extending this map and dropping art in digital_images/
const CLASS_MAP = {
  ladybug: {label:'Ladybug', archetype:'tank', art:'digital_images/ladybug.jpeg'},
  squirrel:{label:'Squirrel', archetype:'speedster', art:'digital_images/squirrel.jpeg'},
  dog:     {label:'Dog', archetype:'guardian', art:'digital_images/dog.jpeg'},
  cat:     {label:'Cat', archetype:'rogue', art:'digital_images/cat.jpeg'},
  spider:  {label:'Spider', archetype:'trapper', art:'digital_images/spider.jpeg'},
  fly:     {label:'Fly', archetype:'plague', art:'digital_images/fly.jpeg'},
};

// Boss art placeholders
const BOSS_ART = [
  {key:'tiger',    name:'Tiger Overlord',    art:'boss_images/tiger_boss.jpeg'},
  {key:'bear',     name:'Elder Bear',        art:'boss_images/bear_boss.jpeg'},
  {key:'shark',    name:'Abyssal Shark',     art:'boss_images/shark_boss.jpeg'},
  {key:'lion',     name:'Sun Pride King',    art:'boss_images/lion_boss.jpeg'},
  {key:'snake',    name:'Venom Sovereign',   art:'boss_images/snake_boss.jpeg'},
  {key:'alligator',name:'Bog Colossus',      art:'boss_images/alligator_boss.jpeg'},
  {key:'pelican',  name:'Typhoon Carrier',   art:'boss_images/pelican_boss.jpeg'},
];

/* =========================
   1) STATE & STORAGE
   ========================= */
const LS = {
  inv:'ml_inventory_v3',
  team:'ml_team_v3',
  seen:'ml_seen_hashes_v3',
  loot:'ml_loot_v3',
  kills:'ml_kills_v3',
  myth:'ml_mythic_v3',
  cap:'ml_capacity_v3'
};
let model=null, webcamStream=null, currentFacing='environment';

let inventory = loadLS(LS.inv, []);
let team = loadLS(LS.team, []);
let lootBag = loadLS(LS.loot, []);
let kills = loadLS(LS.kills, {wild:0,miniboss:0,boss:0});
let mythicLedger = loadLS(LS.myth, []);
let invCapacity = loadLS(LS.cap, INVENTORY_CAP_START);

function saveAll(){
  localStorage.setItem(LS.inv, JSON.stringify(inventory));
  localStorage.setItem(LS.team, JSON.stringify(team));
  localStorage.setItem(LS.loot, JSON.stringify(lootBag));
  localStorage.setItem(LS.kills, JSON.stringify(kills));
  localStorage.setItem(LS.myth, JSON.stringify(mythicLedger));
  localStorage.setItem(LS.cap, JSON.stringify(invCapacity));
}
function loadLS(k, d){ try{return JSON.parse(localStorage.getItem(k)) ?? d}catch{return d} }

/* =========================
   2) PRELOAD IMAGES
   ========================= */
[...Object.values(CLASS_MAP).map(x=>x.art), ...BOSS_ART.map(x=>x.art)]
  .forEach(src=>{ const i=new Image(); i.src=src; });

/* =========================
   3) CAMERA + MODEL
   ========================= */
const webcamEl = document.getElementById('webcam');
const startCamBtn = document.getElementById('startCamBtn');
const flipBtn = document.getElementById('flipBtn');
const captureBtn = document.getElementById('captureBtn');
const uploadBtn = document.getElementById('uploadBtn');
const fileInput = document.getElementById('fileInput');
const capErr = document.getElementById('capErr');
const canvas = document.getElementById('captureCanvas');

startCamBtn.addEventListener('click', startCamera);
flipBtn.addEventListener('click', async ()=>{ currentFacing = currentFacing==='environment'?'user':'environment'; await startCamera(); });
uploadBtn.addEventListener('click', ()=>fileInput.click());
fileInput.addEventListener('change', handleUpload);
captureBtn.addEventListener('click', handleCapture);
window.addEventListener('pageshow',()=>{ /* iOS back-forward cache fix */ if(document.querySelector('.tab-btn.active')?.dataset.tab==='capture') startCamera(); });
window.addEventListener('visibilitychange',()=>{ if(document.hidden) stopCamera(); });

async function ensureModel(){
  if(model) return;
  // quick check
  for(const f of ["model.json","metadata.json","weights.bin"]){
    try{ const r=await fetch(MODEL_URL+f,{cache:"no-store"}); console.log(r.ok?`‚úÖ ${f}`:`‚ùå ${f} (${r.status})`) }catch(e){ console.warn("Fetch",f,e) }
  }
  model = await tmImage.load(MODEL_URL+"model.json", MODEL_URL+"metadata.json");
}
async function startCamera(){
  capErr.textContent='';
  try{
    await ensureModel();
    if(webcamStream){ webcamStream.getTracks().forEach(t=>t.stop()); }
    const constraints = {
      video:{ facingMode:{ideal:currentFacing}, width:{ideal:1280}, height:{ideal:720} }, audio:false
    };
    webcamStream = await navigator.mediaDevices.getUserMedia(constraints);
    webcamEl.srcObject = webcamStream;
    // ensure attributes for iOS
    webcamEl.setAttribute('playsinline',''); webcamEl.setAttribute('autoplay',''); webcamEl.muted=true;
    await webcamEl.play();
  }catch(err){
    capErr.textContent = `Camera error: ${err.name} ‚Äî ${err.message}. Try Upload.`;
    console.error(err);
  }
}
function stopCamera(){ if(webcamStream){ webcamStream.getTracks().forEach(t=>t.stop()); webcamStream=null } }

/* =========================
   4) CAPTURE / UPLOAD / DUPLICATE
   ========================= */
async function handleCapture(){
  if(!webcamStream){ capErr.textContent="No webcam stream available."; return; }
  const w=webcamEl.videoWidth, h=webcamEl.videoHeight;
  if(!w||!h){ capErr.textContent="Camera not ready yet."; return; }
  canvas.width=w; canvas.height=h;
  const ctx=canvas.getContext('2d'); ctx.drawImage(webcamEl,0,0,w,h);
  await processCanvas(canvas);
}
async function handleUpload(e){
  const file = e.target.files[0]; if(!file) return;
  const img = new Image();
  img.onload = async ()=>{ canvas.width=img.width; canvas.height=img.height; const c=canvas.getContext('2d'); c.drawImage(img,0,0); await processCanvas(canvas); };
  img.src = URL.createObjectURL(file);
}

/* average hash duplicate guard (8x8) */
function aHash(cnv){
  const t=document.createElement('canvas'); t.width=8; t.height=8;
  const x=t.getContext('2d'); x.drawImage(cnv,0,0,8,8);
  const d=x.getImageData(0,0,8,8).data;
  let gray=[],sum=0;
  for(let i=0;i<64;i++){ const r=d[i*4],g=d[i*4+1],b=d[i*4+2]; const v=Math.round(0.299*r+0.587*g+0.114*b); gray.push(v); sum+=v; }
  const avg=sum/64; let bits=''; for(const v of gray) bits += (v>avg?'1':'0'); return bits;
}
function duplicateRecently(hash){
  const key=LS.seen; let store=loadLS(key,[]); const now=Date.now();
  store=store.filter(e=> now-e.t < DUPLICATE_COOLDOWN_MINUTES*60*1000);
  const seen=store.find(e=>e.h===hash);
  if(seen) return true;
  store.push({h:hash,t:now}); localStorage.setItem(key, JSON.stringify(store)); return false;
}

async function processCanvas(cnv){
  await ensureModel();
  const hash=aHash(cnv);
  if(duplicateRecently(hash)){ showResultError("Duplicate photo detected recently. Try a new subject/angle."); return; }
  let preds = await model.predict(cnv);
  preds.sort((a,b)=>b.probability - a.probability);
  const top = preds[0];
  if(!top || top.probability < CONFIDENCE_THRESHOLD){
    const m = createMonsterFromClass(null, 'wild', null);
    renderResultCard(m, true);
    return;
  }
  const cls=(top.className||'').toLowerCase().trim();
  const m = createMonsterFromClass(cls, 'wild', top.probability);
  renderResultCard(m, false);
}

/* =========================
   5) MONSTER FACTORY
   ========================= */
function rollRarity(table=RARITY){
  const r=Math.random()*100; let acc=0;
  for(const row of table){ acc+=row.pct; if(r<=acc) return row.key }
  return 'common';
}
function rngIn([a,b]){ return Math.floor(a + Math.random()*(b-a+1)) }
function uid(){ return 'm_'+Math.random().toString(36).slice(2)+Date.now().toString(36) }
function xpForNext(level){ return Math.floor(35 + Math.pow(level,1.6)*12) }

function rarityMult(key){
  const row = [...RARITY,...BOSS_RARITY,...MINIBOSS_RARITY].find(r=>r.key===key);
  return row?row.mult:1;
}

function createMonsterFromClass(clsKey, origin='wild', conf=null, forcedRarity=null, bossMeta=null){
  let label, archeKey, art;
  if(!clsKey || !CLASS_MAP[clsKey]){
    label=UNKNOWN_NAME; archeKey='brawler';
    art = (Object.values(CLASS_MAP)[Math.floor(Math.random()*Object.values(CLASS_MAP).length)]).art;
  }else{
    ({label, art} = CLASS_MAP[clsKey]); archeKey = CLASS_MAP[clsKey].archetype;
  }
  const arch=ARCHETYPES[archeKey];
  const rarity = forcedRarity || rollRarity(origin==='boss'?BOSS_RARITY:origin==='miniboss'?MINIBOSS_RARITY:RARITY);
  const rMult = rarityMult(rarity);
  const base = {
    hp:rngIn(arch.hp), atk:rngIn(arch.atk), def:rngIn(arch.def), spd:rngIn(arch.spd), stamina:rngIn(arch.stamina)
  };
  for(const k of ['hp','atk','def','spd','stamina']) base[k]=Math.round(base[k]*rMult);
  const m={
    id:uid(),
    name:label, cls:clsKey||'unknown', rarity, element:arch.element,
    level:1, xp:0, evo:0, shards:0,
    hp:base.hp, atk:base.atk, def:base.def, spd:base.spd, stamina:base.stamina,
    curHp:base.hp, curStam:base.stamina,
    art, origin, confidence:conf, bossMeta:bossMeta||null, favorite:false
  };
  return m;
}

/* =========================
   6) RESULT CARD + ADD
   ========================= */
const resultEl=document.getElementById('result');
function showResultError(msg){ resultEl.innerHTML=`<p class="error">${msg}</p>` }
function glowDiv(r){ return `<div class="glow ${r}"></div>` }
function pct(n,den){ return Math.max(0,Math.min(100,Math.round(n/den*100))) }
function monsterCardHTML(m, withActions=true){
  const bar=(label,val,max,cls)=>`
    <div>
      <div class="stack" style="justify-content:space-between"><span>${label}</span><span>${val}/${max}</span></div>
      <div class="statbar"><div class="fill ${cls}" style="width:${pct(val,max)}%"></div></div>
    </div>`;
  return `
  <div class="card">
    ${glowDiv(m.rarity)}
    <div class="title">
      <div><strong>${m.name}</strong> <span class="badge ${m.rarity}">${m.rarity.toUpperCase()}</span> <span class="badge">${m.element}</span> ${m.favorite?"üíö Best Pal":""}</div>
      <div>Lv ${m.level} (${m.evo}‚òÖ)</div>
    </div>
    <img class="art" src="${m.art}" alt="${m.name}">
    <div class="row">
      <div class="col">${bar("HP",m.curHp,m.hp,"hp")}</div>
      <div class="col">${bar("Stamina",m.curStam,m.stamina,"stam")}</div>
    </div>
    <div class="stack">
      <span class="pill">ATK ${m.atk}</span>
      <span class="pill">DEF ${m.def}</span>
      <span class="pill">SPD ${m.spd}</span>
      <span class="pill">XP ${m.xp}/${xpForNext(m.level)}</span>
    </div>
    ${withActions?`
    <div class="stack">
      <button class="btn good" data-act="addInv" data-id="${m.id}">‚ûï Add to Inventory</button>
      <button class="btn" data-act="toTeam" data-id="${m.id}">‚≠ê Add to Team</button>
    </div>`:''}
  </div>`;
}
function renderResultCard(m, wasUnknown){
  resultEl.innerHTML = monsterCardHTML(m,true);
  resultEl.querySelectorAll('button').forEach(b=>b.addEventListener('click', e=>{
    const act=e.target.getAttribute('data-act'); if(act==='addInv') addToInventory(m); if(act==='toTeam') addToTeam(m);
  }));
  if(wasUnknown) resultEl.insertAdjacentHTML('afterbegin', `<div class="muted">Low confidence ‚Äî spawned a <em>${UNKNOWN_NAME}</em>.</div>`);
}

/* =========================
   7) INVENTORY & TEAM
   ========================= */
const invEl=document.getElementById('inventory');
const teamEl=document.getElementById('team');
const invUsedEl=document.getElementById('invUsed');
const invCapEl=document.getElementById('invCap');
const expandInvBtn=document.getElementById('expandInvBtn');
const ownedCountEl=document.getElementById('ownedCount');
const mythicCountEl=document.getElementById('mythicCount');
invCapEl.textContent = invCapacity;

expandInvBtn.addEventListener('click', ()=>{ invCapacity+=10; invCapEl.textContent=invCapacity; saveAll(); renderAll(); });

function addToInventory(m){
  if(inventory.length>=invCapacity){ alert("Inventory full ‚Äî break down or expand capacity."); return; }
  inventory.push(m);
  if(m.rarity==='mythic') mythicLedger.push({id:m.id,name:m.name,at:Date.now()});
  saveAll(); renderAll(); flyToInventory();
}
function breakDown(id){
  const ix=inventory.findIndex(x=>x.id===id); if(ix<0) return;
  const m=inventory[ix];
  const baseByRarity={common:1,uncommon:2,rare:4,epic:8,legendary:15,mythic:25};
  const shards = baseByRarity[m.rarity] + Math.floor(m.level/5);
  addLoot({type:'shard', key:m.cls||'unknown', name:`${(m.cls||'unknown').toUpperCase()} Shard`, qty:shards, rarity:m.rarity});
  inventory.splice(ix,1); team=team.filter(t=>t!==id);
  saveAll(); renderAll();
}
function toggleFavorite(id){
  inventory.forEach(x=>x.favorite=false);
  const m=inventory.find(x=>x.id===id); if(m){ m.favorite=true; saveAll(); renderAll(); }
}
function evolveWithShards(id){
  const m=inventory.find(x=>x.id===id); if(!m) return;
  if(m.evo>=EVOLVE_MAX){ alert("Max evolution reached"); return; }
  const gate = EVOLVE_LEVEL_GATES[m.evo] || 999;
  if(m.level<gate){ alert(`Requires level ${gate} to evolve to ${m.evo+1}‚òÖ`); return; }
  const cost = 5*(m.evo+1);
  const have = getShardCount(m.cls||'unknown'); if(have<cost){ alert(`Need ${cost} shards, you have ${have}`); return; }
  spendShards(m.cls||'unknown', cost);
  m.evo++;
  m.hp=Math.round(m.hp*1.10); m.atk=Math.round(m.atk*1.10); m.def=Math.round(m.def*1.10); m.spd=Math.round(m.spd*1.06); m.stamina=Math.round(m.stamina*1.08);
  m.curHp=m.hp; m.curStam=m.stamina; saveAll(); renderAll();
}
function addToTeam(m){
  if(!inventory.find(x=>x.id===m.id)) addToInventory(m);
  if(team.includes(m.id)){ alert("Already on team"); return; }
  if(team.length>=TEAM_SIZE){
    if(confirm("Team full. Replace the last slot with this monster?")){ team.pop(); team.push(m.id); } else return;
  }else team.push(m.id);
  saveAll(); renderAll();
}
function removeFromTeam(id){ team=team.filter(x=>x!==id); saveAll(); renderAll(); }

function renderInventory(){
  invUsedEl.textContent = inventory.length; ownedCountEl.textContent = inventory.length; mythicCountEl.textContent = mythicLedger.length;
  invEl.innerHTML = inventory.map(m=>`
    <div class="card">
      ${glowDiv(m.rarity)}
      <div class="title"><div><strong>${m.name}</strong> <span class="badge ${m.rarity}">${m.rarity.toUpperCase()}</span> <span class="badge">${m.element}</span></div><div>Lv ${m.level} (${m.evo}‚òÖ)</div></div>
      <img class="art" src="${m.art}">
      <div class="stack"><span class="pill">HP ${m.hp}</span><span class="pill">ATK ${m.atk}</span><span class="pill">DEF ${m.def}</span><span class="pill">SPD ${m.spd}</span></div>
      <div class="stack">
        <button class="btn" data-do="favorite" data-id="${m.id}">${m.favorite?"üíö Best Pal":"‚ô° Set Best Pal"}</button>
        <button class="btn good" data-do="team" data-id="${m.id}">‚≠ê Team</button>
      </div>
      <div class="stack">
        <button class="btn warn" data-do="evolve" data-id="${m.id}">‚¨ÜÔ∏è Evolve (shards)</button>
        <button class="btn" data-do="break" data-id="${m.id}">‚ôª Break ‚Üí shards</button>
        <button class="btn ghost" data-do="delete" data-id="${m.id}">üóë Remove</button>
      </div>
    </div>`).join('');
  invEl.querySelectorAll('button').forEach(b=>{
    const id=b.getAttribute('data-id'); const act=b.getAttribute('data-do');
    b.onclick=()=>{
      if(act==='favorite') toggleFavorite(id);
      if(act==='team'){ const m=inventory.find(x=>x.id===id); if(m) addToTeam(m); }
      if(act==='break') breakDown(id);
      if(act==='delete'){ if(confirm("Remove from inventory? (No shards)")){ inventory=inventory.filter(x=>x.id!==id); team=team.filter(x=>x!==id); saveAll(); renderAll(); } }
      if(act==='evolve') evolveWithShards(id);
    };
  });
}
function renderTeam(){
  teamEl.innerHTML = team.map(id=>{
    const m=inventory.find(x=>x.id===id); if(!m) return '';
    return `<div class="card">
      ${glowDiv(m.rarity)}
      <div class="title"><strong>${m.name}</strong><span>Lv ${m.level} (${m.evo}‚òÖ)</span></div>
      <img class="art" src="${m.art}">
      <div class="stack"><span class="pill">ATK ${m.atk}</span><span class="pill">DEF ${m.def}</span><span class="pill">SPD ${m.spd}</span></div>
      <button class="btn" data-kick="${m.id}">Remove</button>
    </div>`;
  }).join('');
  teamEl.querySelectorAll('button[data-kick]').forEach(b=>b.onclick=()=>removeFromTeam(b.getAttribute('data-kick')));
}

/* =========================
   8) LOOT (STACKING)
   ========================= */
const lootListEl=document.getElementById('lootList');
const battleLootEl=document.getElementById('battleLoot');
const invAnchor=document.getElementById('inventoryAnchor');

function addLoot(item){ // {type,key,name,qty,rarity}
  const exist = lootBag.find(x=>x.type===item.type && x.key===item.key && x.rarity===item.rarity);
  if(exist) exist.qty += item.qty; else lootBag.push({...item});
  saveAll(); renderLoot();
}
function getShardCount(cls){ const row=lootBag.find(x=>x.type==='shard'&&x.key===cls); return row?row.qty:0; }
function spendShards(cls,n){ const row=lootBag.find(x=>x.type==='shard'&&x.key===cls); if(!row) return false; row.qty-=n; if(row.qty<=0) lootBag=lootBag.filter(x=>x!==row); saveAll(); renderLoot(); return true; }

function renderLoot(){
  lootListEl.innerHTML = lootBag.map(it=>`
    <div class="card">
      <div class="title"><strong>${it.name}</strong> <span class="badge ${it.rarity||'common'}">${(it.rarity||'common').toUpperCase()}</span></div>
      <div class="stack"><span class="pill">Type: ${it.type}</span><span class="pill">Qty: ${it.qty}</span></div>
    </div>`).join('');
}

function flyToInventory(){
  const srcEl = document.querySelector('#result img.art') || document.querySelector('#enemyCard img.art') || document.querySelector('#modalEnemy img.art');
  if(!srcEl) return;
  const b=srcEl.getBoundingClientRect(), t=invAnchor.getBoundingClientRect();
  const ghost=srcEl.cloneNode(); ghost.className='fly'; ghost.style.left=b.left+'px'; ghost.style.top=b.top+'px'; ghost.style.width=b.width+'px'; ghost.style.height=b.height+'px'; document.body.appendChild(ghost);
  requestAnimationFrame(()=>{ ghost.style.transform=`translate(${t.left-b.left}px, ${t.top-b.top}px) scale(0.1)`; ghost.style.opacity='0'; });
  setTimeout(()=>ghost.remove(),950);
}

/* =========================
   9) BATTLES + MODAL
   ========================= */
const yourTeamEl=document.getElementById('yourTeam');
const enemyCardEl=document.getElementById('enemyCard');
const battleLogEl=document.getElementById('battleLog');
const fightWildBtn=document.getElementById('fightWildBtn');
const fightMiniBtn=document.getElementById('fightMiniBtn');
const fightBossBtn=document.getElementById('fightBossBtn');
const killCountEl=document.getElementById('killCount');

// Modal bits
const resultModal=document.getElementById('resultModal');
const modalTitle=document.getElementById('modalTitle');
const modalTeam=document.getElementById('modalTeam');
const modalEnemy=document.getElementById('modalEnemy');
const modalLoot=document.getElementById('modalLoot');
const closeModal=document.getElementById('closeModal');
closeModal.onclick = ()=>{ resultModal.style.display='none'; };

fightWildBtn.onclick=()=>startBattle('wild');
fightMiniBtn.onclick=()=>startBattle('miniboss');
fightBossBtn.onclick=()=>startBattle('boss');

function renderTeamMini(){
  yourTeamEl.innerHTML = team.map(id=>{
    const m=inventory.find(x=>x.id===id); if(!m) return '';
    return `<div class="card">
      <div class="title"><strong>${m.name}</strong><span>Lv ${m.level}</span></div>
      <img class="art" src="${m.art}">
      <div class="stack"><span class="pill">${m.atk} ATK</span><span class="pill">${m.def} DEF</span><span class="pill">${m.spd} SPD</span></div>
    </div>`;
  }).join('');
}
function pickEnemy(tier){
  if(tier==='wild'){
    const keys=Object.keys(CLASS_MAP);
    const k=keys[Math.floor(Math.random()*keys.length)];
    return createMonsterFromClass(k,'wild',null,null,null);
  }
  const boss = BOSS_ART[Math.floor(Math.random()*BOSS_ART.length)];
  const m = createMonsterFromClass(null, tier, null, tier==='boss'?'epic':'rare', {name:boss.name});
  m.name=boss.name; m.art=boss.art;
  if(tier==='miniboss'){ m.level=8+Math.floor(Math.random()*5); m.hp*=2.0; m.atk=Math.round(m.atk*1.4); m.def=Math.round(m.def*1.4); }
  if(tier==='boss'){ m.level=15+Math.floor(Math.random()*6); m.hp*=3.0; m.atk=Math.round(m.atk*1.9); m.def=Math.round(m.def*1.8); }
  return m;
}
function startBattle(tier){
  if(team.length===0){ alert("Add at least one monster to your team."); return; }
  renderTeamMini();
  const enemy=pickEnemy(tier);
  enemyCardEl.innerHTML = monsterCardHTML(enemy,false);
  battleLogEl.textContent = "Battle started!\n";
  const us = team.map(id=>structuredClone(inventory.find(x=>x.id===id))).filter(Boolean);
  const fav = inventory.find(x=>x.favorite); if(fav){ const slot=us.find(x=>x.id===fav.id); if(slot){ slot.atk+=5; slot.hp+=10; slot.curHp=slot.hp; } }

  let turn=0;
  while(enemy.curHp>0 && us.some(x=>x.curHp>0) && turn<120){
    turn++;
    const attacker = us.filter(x=>x.curHp>0).sort((a,b)=>b.spd-a.spd)[0];
    const dmg = Math.max(1, Math.round((attacker.atk*1.2) - (enemy.def*0.5)));
    enemy.curHp -= dmg; battleLogEl.textContent += `${attacker.name} hits ${enemy.name} for ${dmg}\n`;
    if(enemy.curHp<=0) break;
    const targets = us.filter(x=>x.curHp>0);
    const t = targets[Math.floor(Math.random()*targets.length)];
    const edmg = Math.max(1, Math.round((enemy.atk*1.1) - (t.def*0.5)));
    t.curHp -= edmg; battleLogEl.textContent += `${enemy.name} hits ${t.name} for ${edmg}\n`;
  }

  const victory = enemy.curHp<=0;
  if(victory){
    battleLogEl.textContent += `\nüéâ Victory!`;
    addWinRewards(tier, us, enemy);
    if(tier==='wild') kills.wild++; else if(tier==='miniboss') kills.miniboss++; else kills.boss++;
    showBattleResultModal(true, us, enemy, tier);
  }else{
    battleLogEl.textContent += `\nüíÄ Defeat... Try leveling or evolving!`;
    showBattleResultModal(false, us, enemy, tier);
  }
  localStorage.setItem(LS.kills, JSON.stringify(kills));
  killCountEl.textContent = (kills.wild + kills.miniboss + kills.boss).toString();
}
function addWinRewards(tier, ourTeam, enemy){
  const base = BASE_XP_PER_WIN * (tier==='boss'?5: tier==='miniboss'?3:1);
  ourTeam.forEach(m=>{
    const live=inventory.find(x=>x.id===m.id); if(!live) return;
    live.xp += base;
    while(live.xp>=xpForNext(live.level)){
      live.xp -= xpForNext(live.level);
      live.level++; live.hp+=5; live.atk+=2; live.def+=2; live.spd+=1; live.stamina+=3;
      live.curHp=live.hp; live.curStam=live.stamina;
      battleLogEl.textContent += `\n‚¨ÜÔ∏è ${live.name} reached Lv ${live.level}!`;
    }
  });

  battleLootEl.innerHTML='';
  const drops = (tier==='boss')?bossDrops(): (tier==='miniboss')?miniDrops():wildDrops();
  for(const d of drops){
    addLoot(d);
    const tag=document.createElement('span'); tag.className=`badge ${d.rarity||'common'}`; tag.textContent=`+${d.qty} ${d.name}`;
    battleLootEl.appendChild(tag);
    flyToInventory();
  }
  saveAll(); renderAll();
}
function wildDrops(){
  const out=[];
  if(Math.random()<0.40){
    const keys=Object.keys(CLASS_MAP); const k=keys[Math.floor(Math.random()*keys.length)];
    out.push({type:'shard',key:k,name:`${k.toUpperCase()} Shard`,qty:1,rarity:'common'});
  }
  if(Math.random()<0.001){ out.push({type:'trinket',key:'wild_myth',name:'Wild Mythic Trinket',qty:1,rarity:'mythic'}) }
  return out;
}
function miniDrops(){
  const out=[];
  const keys=Object.keys(CLASS_MAP); const k=keys[Math.floor(Math.random()*keys.length)];
  out.push({type:'shard',key:k,name:`${k.toUpperCase()} Shard`,qty:2,rarity:'uncommon'});
  if(Math.random()<0.05){ out.push({type:'part',key:'mini_fang',name:'Mini-Boss Fang',qty:1,rarity:'rare'}) }
  if(Math.random()<0.0005){ out.push({type:'relic',key:'mini_relic',name:'Mini Relic',qty:1,rarity:'mythic'}) }
  return out;
}
function bossDrops(){
  const out=[];
  const keys=Object.keys(CLASS_MAP); const k=keys[Math.floor(Math.random()*keys.length)];
  out.push({type:'shard',key:k,name:`${k.toUpperCase()} Shard`,qty:5,rarity:'rare'});
  if(Math.random()<0.20){ out.push({type:'part',key:'boss_horn',name:'Boss Horn',qty:1,rarity:'legendary'}) }
  if(Math.random()<0.001){ out.push({type:'relic',key:'mythic_core',name:'Mythic Core',qty:1,rarity:'mythic'}) }
  return out;
}

/* Modal renderer */
function showBattleResultModal(victory, ourTeam, enemy, tier){
  modalTitle.textContent = victory ? (tier==='boss'?'üèÜ Boss Defeated!':'üéâ Victory!') : 'üíÄ Defeat';
  modalTeam.innerHTML = ourTeam.map(m=>`
    <div class="card"><div class="title"><strong>${m.name}</strong><span>Lv ${m.level}</span></div><img class="art" src="${m.art}"></div>
  `).join('');
  modalEnemy.innerHTML = monsterCardHTML(enemy,false);
  // Copy last battle loot chips
  modalLoot.innerHTML = document.getElementById('battleLoot').innerHTML;
  resultModal.style.display='flex';
}

/* =========================
   10) TABS & MYTHICS
   ========================= */
const tabs=document.querySelectorAll('.tab-btn');
const sections={
  capture:document.getElementById('tab-capture'),
  inventory:document.getElementById('tab-inventory'),
  team:document.getElementById('tab-team'),
  battle:document.getElementById('tab-battle'),
  loot:document.getElementById('tab-loot'),
  mythics:document.getElementById('tab-mythics'),
};
tabs.forEach(t=>t.onclick=()=>{
  tabs.forEach(b=>b.classList.remove('active')); t.classList.add('active');
  Object.values(sections).forEach(s=>s.style.display='none');
  const tab=t.dataset.tab; sections[tab].style.display='';
  if(tab==='capture'){ startCamera(); } else { stopCamera(); }
  if(tab==='battle'){ renderTeamMini(); }
});
const mythicList=document.getElementById('mythicList');
function renderMythics(){ mythicList.innerHTML = mythicLedger.map(m=>`
  <div class="card"><div class="title"><strong>${m.name}</strong><span class="muted">${new Date(m.at).toLocaleString()}</span></div></div>
`).join(''); }

/* =========================
   11) INITIAL RENDER
   ========================= */
const killCountEl=document.getElementById('killCount');
function renderAll(){ renderInventory(); renderTeam(); renderLoot(); renderMythics(); killCountEl.textContent=(kills.wild+kills.miniboss+kills.boss).toString(); }
renderAll();

/* =========================
   12) SMALL HELPERS
   ========================= */
function showToast(msg){ console.log(msg); }
</script>
</body>
</html>
<style>
  :root{
    --bg:#111; --panel:#1b1b1b; --soft:#222; --accent:#77e; --good:#4caf50; --warn:#ffc107; --bad:#e53935;
    --rare:#72e5ff; --epic:#b388ff; --legend:#ffcc80; --mythic:#ff6ec7; --ultra:#ffd700;
  }
  html,body{margin:0;padding:0;background:var(--bg);color:#eee;font-family:Inter,system-ui,Arial;}
  header{padding:14px 12px;text-align:center;background:linear-gradient(90deg,#222,#191919);position:sticky;top:0;z-index:5}
  .title{font-weight:800;letter-spacing:.5px}
  .sub{opacity:.8;font-size:.95rem}
  .wrap{max-width:1100px;margin:0 auto;padding:12px}
  .grid{display:grid;grid-template-columns:1fr;gap:12px}
  @media(min-width:900px){ .grid{grid-template-columns: 1.1fr .9fr} }

  /* Camera panel */
  .card{background:var(--panel);border:1px solid #2a2a2a;border-radius:16px;padding:12px;position:relative;overflow:hidden}
  .section-title{font-weight:700;margin:4px 0 8px}
  video,canvas{width:100%;max-height:360px;background:#000;border-radius:12px}
  .controls{display:flex;gap:8px;flex-wrap:wrap;margin-top:8px}
  button{background:#2b2b2b;border:1px solid #3a3a3a;color:#fff;padding:10px 14px;border-radius:12px;cursor:pointer}
  button:hover{filter:brightness(1.1)}
  .primary{background:linear-gradient(90deg,#5561ff,#a25bff);border:none}
  .danger{background:linear-gradient(90deg,#a33,#d33);border:none}
  .ghost{background:#262626}

  /* Tabs */
  .tabs{display:flex;gap:8px;margin:8px 0 4px;flex-wrap:wrap}
  .tab{padding:8px 12px;border-radius:999px;background:#222;border:1px solid #2e2e2e;cursor:pointer}
  .tab.active{background:#333;border-color:#555}

  /* Inventory & Team */
  .row{display:flex;gap:10px;flex-wrap:wrap}
  .pill{padding:4px 10px;border-radius:999px;background:#1f1f1f;border:1px solid #2c2c2c;font-size:.85rem}
  .slot{background:#181818;border:1px dashed #3a3a3a;border-radius:12px;min-width:120px;min-height:120px;display:flex;flex-direction:column;align-items:center;justify-content:center;gap:6px;padding:10px;position:relative}
  .slot img{max-width:96px;max-height:96px;object-fit:contain}
  .slot .name{font-weight:700;font-size:.9rem}
  .slot .rar{font-size:.75rem;opacity:.85}

  /* Rarity glow around card borders */
  .glow-Common{box-shadow:0 0 0 0 transparent}
  .glow-Uncommon{box-shadow:0 0 8px 0 rgba(114,229,255,.25)}
  .glow-Rare{box-shadow:0 0 10px 1px rgba(179,136,255,.35)}
  .glow-Epic{box-shadow:0 0 12px 2px rgba(255,204,128,.40)}
  .glow-Legendary{box-shadow:0 0 12px 2px rgba(255,110,199,.45)}
  .glow-Mythic{box-shadow:0 0 14px 3px rgba(255,215,0,.55)}

  /* Bars */
  .bar{height:10px;background:#333;border-radius:6px;overflow:hidden}
  .bar>span{display:block;height:100%}
  .hp{background:var(--bad)}
  .sta{background:var(--good)}

  /* Monster Card */
  .monster-card{background:var(--soft);border:1px solid #2e2e2e;border-radius:16px;padding:12px;margin-top:10px;position:relative;overflow:hidden}
  .monster-head{display:flex;gap:10px;align-items:center}
  .monster-img{width:120px;height:120px;background:#0b0b0b;border-radius:14px;display:flex;align-items:center;justify-content:center;overflow:hidden}
  .monster-img img{max-width:100%;max-height:100%;object-fit:contain}
  .statgrid{display:grid;grid-template-columns:repeat(2,1fr);gap:6px;margin-top:10px}
  .stat{background:#1f1f1f;border:1px solid #2b2b2b;border-radius:10px;padding:8px;font-size:.9rem}
  .badge{padding:3px 8px;border-radius:999px;font-size:.75rem;border:1px solid #333;background:#1d1d1d}
  .rarC{background:#1a2230;border-color:#294b8a}
  .rarU{background:#112a2e;border-color:#16515a}
  .rarR{background:#1d1530;border-color:#3f2a7a}
  .rarE{background:#2b1e09;border-color:#7a4c1b}
  .rarL{background:#321428;border-color:#7a2c5d}
  .rarM{background:#332900;border-color:#7a6a1b}

  /* Toast/overlay & fly-to-inventory animation */
  .toast{position:fixed;left:50%;transform:translateX(-50%);bottom:22px;background:#222;border:1px solid #444;padding:10px 14px;border-radius:12px;z-index:50}
  .loot-fly{position:fixed;pointer-events:none;transition:transform .9s cubic-bezier(.22,1,.36,1), opacity .9s; z-index:60}
  .silhouette{filter:brightness(.0) saturate(0);opacity:.95}

  /* Cinematic modal */
  .modal{position:fixed;inset:0;background:rgba(0,0,0,.75);display:none;align-items:center;justify-content:center;z-index:70}
  .modal.show{display:flex}
  .modal-card{background:#141414;border:1px solid #2a2a2a;border-radius:16px;padding:16px;max-width:640px;width:92%;text-align:center}
</style>

<!-- TFJS + Teachable Machine (use these pinned versions for stability) -->
<script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@3.21.0/dist/tf.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@teachablemachine/image@0.8.4/dist/teachablemachine-image.min.js"></script>
</head>
<body>
<header>
  <div class="title">Monster Transform ‚Äî PvPvE Beta</div>
  <div class="sub">Capture real animals ‚Üí transform into digital monsters ‚Ä¢ Build team ‚Ä¢ Battle wilds & bosses ‚Ä¢ Loot & Upgrades</div>
</header>

<div class="wrap grid">

  <!-- LEFT: Camera + Capture + Result -->
  <section class="card" id="cameraCard">
    <div class="section-title">üì∑ Capture</div>
    <video id="webcam" autoplay playsinline muted></video>
    <canvas id="frameCanvas" style="display:none;"></canvas>
    <div class="controls">
      <button class="primary" id="btnStartCam">Start Camera</button>
      <button id="btnCapture">Capture Photo</button>
      <input type="file" id="fileInput" accept="image/*" capture="environment" style="display:none" />
      <button class="ghost" id="btnUpload">Upload Photo</button>
      <button class="danger" id="btnStopCam">Stop Camera</button>
    </div>
    <div id="camError" class="pill" style="display:none;background:#2d1919;border-color:#5a2b2b;color:#ffb3b3;margin-top:8px"></div>

    <div id="resultZone"></div>
  </section>

  <!-- RIGHT: Tabs, Inventory, Team, Battles -->
  <section class="card">
    <div class="tabs">
      <div class="tab active" data-tab="inventory">Inventory</div>
      <div class="tab" data-tab="team">Team</div>
      <div class="tab" data-tab="battle">Battle</div>
      <div class="tab" data-tab="upgrades">Upgrades</div>
      <div class="tab" data-tab="loot">Loot</div>
      <div class="tab" data-tab="mythic">Mythics</div>
    </div>

    <div id="panel-inventory">
      <div class="row">
        <span class="pill">Monsters: <span id="invCount">0</span></span>
        <span class="pill">Unique Mythics: <span id="mythCount">0</span></span>
        <span class="pill">Total Kills: <span id="killCount">0</span></span>
      </div>
      <div id="inventoryList" class="row" style="margin-top:8px"></div>
    </div>

    <div id="panel-team" style="display:none">
      <div class="row" style="margin-bottom:6px">
        <span class="pill">Team size: 3</span>
        <button id="btnClearTeam" class="ghost">Clear Team</button>
      </div>
      <div id="teamSlots" class="row"></div>
    </div>

    <div id="panel-battle" style="display:none">
      <div class="row" style="margin-bottom:6px">
        <button class="primary" id="btnWild">Find Wild Fight</button>
        <button id="btnMiniBoss">Mini-Boss</button>
        <button id="btnBoss">Boss</button>
      </div>
      <div id="battleArea"></div>
    </div>

    <div id="panel-upgrades" style="display:none">
      <div class="row" style="margin-bottom:6px;gap:8px">
        <span class="pill">Shards: <span id="shardCount">0</span></span>
        <span class="pill">Gold: <span id="goldCount">0</span></span>
        <span class="pill">Boss Mats: <span id="matCount">0</span></span>
      </div>
      <div id="upgradeArea"></div>
    </div>

    <div id="panel-loot" style="display:none">
      <div id="lootList" class="row"></div>
    </div>

    <div id="panel-mythic" style="display:none">
      <div id="mythicList" class="row"></div>
    </div>
  </section>
</div>

<!-- Cinematic Modal -->
<div class="modal" id="cinematic">
  <div class="modal-card">
    <h2 id="cinTitle">MYTHIC DISCOVERED!</h2>
    <div style="display:flex;gap:12px;align-items:center;justify-content:center;margin-top:10px">
      <div class="monster-img" style="width:160px;height:160px">
        <img id="cinImg" class="silhouette" alt="mythic" />
      </div>
      <div style="text-align:left;max-width:300px">
        <div id="cinText" style="opacity:.9;line-height:1.4"></div>
        <button id="cinClose" class="primary" style="margin-top:10px">Claim</button>
      </div>
    </div>
  </div>
</div>

<div id="toast" class="toast" style="display:none"></div>
<div id="flyLayer"></div>

<script>
/* =========================
   DATA & CONFIG
========================= */

// Model path
const MODEL_URL = "model_real/";

// Camera preferences
const CAM_CONSTRAINTS_PRIMARY   = { video: { facingMode: { ideal: "environment" } }, audio:false };
const CAM_CONSTRAINTS_FALLBACK  = { video: { facingMode: "user" }, audio:false };

// Duplicate-prevention cooldown (ms)
const CAPTURE_COOLDOWN_MS = 6000;

// Rarities & colors
const RARITY_ORDER = ["Common","Uncommon","Rare","Epic","Legendary","Mythic"];
const RARITY_COLOR = {
  Common:"#cfcfcf", Uncommon:"#72e5ff", Rare:"#b388ff",
  Epic:"#ffcc80", Legendary:"#ff6ec7", Mythic:"#ffd700"
};

// Base class templates (lightly themed by your spec)
const CLASS_TEMPLATES = {
  Tank:      { hp: 90, sta: 60, atk: 45, def: 70, spd: 35 },
  Guardian:  { hp: 80, sta: 60, atk: 50, def: 65, spd: 45 },
  Rogue:     { hp: 55, sta: 70, atk: 75, def: 35, spd: 80 },
  Assassin:  { hp: 50, sta: 65, atk: 85, def: 30, spd: 85 },
  Brawler:   { hp: 70, sta: 55, atk: 75, def: 55, spd: 55 },
  Trapper:   { hp: 65, sta: 60, atk: 60, def: 60, spd: 50 },
  Scout:     { hp: 45, sta: 75, atk: 40, def: 30, spd: 95 },
  Speedster: { hp: 60, sta: 65, atk: 55, def: 40, spd: 90 }
};

// Elements and lightweight advantage matrix (rock-paper-ish)
const ELEMENTS = ["Nature","Earth","Shadow","Light","Poison","Air","Water","Fire"];
const E_ADV = {
  Nature:["Earth","Water"],    // nature beats earth & water
  Earth:["Poison","Shadow"],   // etc.
  Shadow:["Light","Nature"],
  Light:["Shadow","Poison"],
  Poison:["Air","Nature"],
  Air:["Earth","Fire"],
  Water:["Fire","Earth"],
  Fire:["Nature","Shadow"]
};

// Your starting set mapped to TM class names:
const MONSTER_DEX = {
  dog:      { element:"Earth",  class:"Guardian", img:"digital_images/dog.jpeg" },
  cat:      { element:"Shadow", class:"Assassin", img:"digital_images/cat.jpeg" },
  squirrel: { element:"Nature", class:"Speedster",img:"digital_images/squirrel.jpeg" },
  spider:   { element:"Poison", class:"Trapper",  img:"digital_images/spider.jpeg" },
  fly:      { element:"Air",    class:"Scout",    img:"digital_images/fly.jpeg" },
  ladybug:  { element:"Light",  class:"Tank",     img:"digital_images/ladybug.jpeg" },
  // Unknown fallback
  "wild beast": { element:"Nature", class:"Brawler", img:"digital_images/ladybug.jpeg" }
};

// Boss & Mini-Boss art placeholders
const BOSS_ART = {
  dragon:"digital_images/boss_dragon.png",
  kraken:"digital_images/boss_kraken.png"
};
const MINIBOSS_ART = {
  wolf:"digital_images/miniboss_wolf.png",
  golem:"digital_images/miniboss_golem.png"
};

// Drop tables
const LOOT_TABLE = {
  wild: [
    { id:"gold_small", name:"Gold Pouch", qty:[10,30],  chance:0.40, rarity:"Common" },
    { id:"shard",      name:"Monster Shard", qty:[1,3], chance:0.20, rarity:"Uncommon" },
    { id:"item_minor", name:"Minor Upgrade Core", qty:[1,1], chance:0.05, rarity:"Rare" }
  ],
  miniboss: [
    { id:"gold_med",   name:"Gold Satchel", qty:[35,75], chance:0.60, rarity:"Uncommon" },
    { id:"shard",      name:"Monster Shard", qty:[2,4], chance:0.40, rarity:"Rare" },
    { id:"mat_wolfFang", name:"Dire Wolf Fang", qty:[1,1], chance:0.15, rarity:"Epic" },
    { id:"mythic_frag", name:"Mythic Fragment", qty:[1,1], chance:0.03, rarity:"Legendary" }, // mini-boss lower rate
  ],
  boss: [
    { id:"gold_big",   name:"Gold Chest", qty:[100,180], chance:0.90, rarity:"Rare" },
    { id:"shard",      name:"Monster Shard", qty:[3,6], chance:0.75, rarity:"Epic" },
    { id:"mat_dragonScale", name:"Ancient Dragon Scale", qty:[1,1], chance:0.35, rarity:"Legendary" },
    { id:"mat_krakenEye",   name:"Kraken‚Äôs Eye", qty:[1,1], chance:0.25, rarity:"Legendary" },
    { id:"mythic_core",     name:"Mythic Core",  qty:[1,1], chance:0.01, rarity:"Mythic" },     // 1%
    { id:"ultra_mythic_spark", name:"Ultra-Mythic Spark", qty:[1,1], chance:0.001, rarity:"Mythic" } // 0.1%
  ]
};

// Rarity rolls for captured monsters
// 1% Rare+, 0.5% Epic+, 0.2% Legendary, 0.05% Mythic; base Uncommon ~5%; rest Common
function rollRarity(){
  const r = Math.random();
  if (r < 0.0005) return "Mythic";      // 0.05%
  if (r < 0.0025) return "Legendary";   // 0.2%
  if (r < 0.0075) return "Epic";        // 0.5%
  if (r < 0.0175) return "Rare";        // 1%
  if (r < 0.0675) return "Uncommon";    // 5%
  return "Common";
}

// Power scaling by rarity (adds onto base class template)
const RARITY_MOD = { Common:0, Uncommon:5, Rare:10, Epic:20, Legendary:30, Mythic:45 };

/* =========================
   STATE & STORAGE
========================= */
let model=null, webcamStream=null, lastCaptureAt=0, lastHash=null;
const $ = s => document.querySelector(s);
const $$ = s => Array.from(document.querySelectorAll(s));

const state = {
  monsters: [],     // [{id,name,element,class,rarity,level,exp,stats,img,hash,createdAt}]
  team: [],         // ids
  loot: {},         // {id: qty}
  killCount: 0,
  mythicsSeen: {},  // {monsterName:true}
  items: {
    weapon:{lvl:0, rarity:"Common"},
    armor:{lvl:0, rarity:"Common"}
  }
};
loadState();

/* =========================
   UTILITIES
========================= */
function uid(){ return 'm'+Math.random().toString(36).slice(2)+Date.now().toString(36); }
function clamp(n,min,max){ return Math.max(min,Math.min(max,n)); }
function randInt(a,b){ return Math.floor(Math.random()*(b-a+1))+a; }
function rarityGlow(r){ return 'glow-'+r; }
function toast(msg){ const t=$("#toast"); t.textContent=msg; t.style.display='block'; setTimeout(()=>t.style.display='none',1600); }
function addLoot(id, qty=1){
  state.loot[id]=(state.loot[id]||0)+qty;
  saveState(); renderLoot();
}

function saveState(){ localStorage.setItem('mt_state', JSON.stringify(state)); }
function loadState(){
  const raw = localStorage.getItem('mt_state');
  if (raw){ try{ Object.assign(state, JSON.parse(raw)); }catch(e){} }
}

/* Tiny image hash to block duplicates */
async function imageHashFromCanvas(cv){
  const c=document.createElement('canvas'), w=32,h=32;
  c.width=w; c.height=h; const ctx=c.getContext('2d');
  ctx.drawImage(cv,0,0,w,h);
  const d=ctx.getImageData(0,0,w,h).data;
  // very simple rolling hash on grayscale
  let hval=0; for(let i=0;i<d.length;i+=4){ const g=(d[i]+d[i+1]+d[i+2])/3|0; hval=((hval<<5)-hval)+g; hval|=0; }
  return String(hval);
}

/* =========================
   CAMERA
========================= */
async function startCamera(){
  stopCamera();
  $("#camError").style.display="none";
  try{
    try{
      webcamStream = await navigator.mediaDevices.getUserMedia(CAM_CONSTRAINTS_PRIMARY);
    }catch(e){
      // Sometimes iOS needs exact constraint flip
      webcamStream = await navigator.mediaDevices.getUserMedia(CAM_CONSTRAINTS_FALLBACK);
    }
    $("#webcam").srcObject=webcamStream;
  }catch(err){
    $("#camError").style.display="block";
    $("#camError").textContent = `Camera error: ${err.name} ‚Äî ${err.message}. You can still Upload Photo.`;
  }
}
function stopCamera(){
  if(!webcamStream) return;
  webcamStream.getTracks().forEach(t=>t.stop());
  webcamStream=null;
  $("#webcam").srcObject=null;
}

async function loadModel(){
  // quick presence check
  for(const f of ["model.json","metadata.json","weights.bin"]){
    try{ const r=await fetch(MODEL_URL+f,{cache:"no-store"}); if(!r.ok) console.warn("Missing/blocked:",f); }
    catch(e){ console.warn("Model fetch error:",f,e); }
  }
  model = await tmImage.load(MODEL_URL+"model.json", MODEL_URL+"metadata.json");
}

/* =========================
   MONSTER CREATION
========================= */
function computeStats(baseClass, rarity){
  const b = CLASS_TEMPLATES[baseClass] || CLASS_TEMPLATES.Brawler;
  const mod = RARITY_MOD[rarity]||0;
  // random +-5% noise
  const n = k => clamp(Math.round((b[k] + mod) * (0.95 + Math.random()*0.1)), 1, 999);
  return { hp:n('hp'), sta:n('sta'), atk:n('atk'), def:n('def'), spd:n('spd') };
}
function xpNeededFor(level){ return Math.round(30 * Math.pow(1.25, level-1)); }

/* Prevent dupes: hash + short cooldown */
function canCapture(hash){
  const now=Date.now();
  if(now-lastCaptureAt < CAPTURE_COOLDOWN_MS) return false;
  // block identical hash in last N monsters
  const recent = state.monsters.slice(-6);
  if(recent.some(m=>m.hash===hash)) return false;
  return true;
}

async function captureFromVideo(){
  if(!webcamStream){ toast("No webcam stream available."); return; }
  const v=$("#webcam");
  if(v.videoWidth===0){ toast("Camera not ready yet."); return; }
  const cv=$("#frameCanvas"), ctx=cv.getContext('2d');
  cv.width=v.videoWidth; cv.height=v.videoHeight;
  ctx.drawImage(v,0,0);
  await handleCapturedCanvas(cv,"camera");
}

async function captureFromFile(file){
  const img = new Image();
  img.onload = async ()=>{
    const cv=$("#frameCanvas"), ctx=cv.getContext('2d');
    cv.width=img.width; cv.height=img.height;
    ctx.drawImage(img,0,0);
    await handleCapturedCanvas(cv,"upload");
  };
  img.src = URL.createObjectURL(file);
}

async function handleCapturedCanvas(canvas, source){
  // hash for dupe protection
  const h = await imageHashFromCanvas(canvas);
  if(!canCapture(h)){ toast("Duplicate or too fast. Try a different shot."); return; }

  // Predict
  let topName = "wild beast";
  try{
    const preds = await model.predict(canvas);
    preds.sort((a,b)=>b.probability-a.probability);
    topName = preds[0]?.className?.toLowerCase() || "wild beast";
  }catch(e){ console.warn("Predict error:",e); }

  const entry = MONSTER_DEX[topName] || MONSTER_DEX["wild beast"];
  const rarity = rollRarity();
  const stats = computeStats(entry.class, rarity);

  const monster = {
    id: uid(),
    name: topName,
    display: topName.replace(/\b\w/g,c=>c.toUpperCase()),
    element: entry.element,
    class: entry.class,
    rarity,
    level: 1,
    exp: 0,
    stats,
    img: entry.img,
    hash: h,
    createdAt: Date.now()
  };

  state.monsters.push(monster);
  // Auto-add to team if space
  if(state.team.length<3) state.team.push(monster.id);

  lastCaptureAt=Date.now(); lastHash=h;
  saveState();
  renderAll();

  // Show card immediately
  showMonsterCard(monster, true);
}

/* =========================
   RENDERING
========================= */
function monsterCardHTML(m){
  const hpPct = clamp(Math.round((m.stats.hp)/120*100), 5,100);
  const staPct= clamp(Math.round((m.stats.sta)/120*100),5,100);
  return `
  <div class="monster-card ${rarityGlow(m.rarity)}">
    <div class="monster-head">
      <div class="monster-img"><img src="${m.img}" alt="${m.name}" /></div>
      <div>
        <div style="display:flex;gap:8px;align-items:center;flex-wrap:wrap">
          <div style="font-weight:800;font-size:1.1rem">${m.display}</div>
          <span class="badge" style="border-color:${RARITY_COLOR[m.rarity]};color:${RARITY_COLOR[m.rarity]}">${m.rarity}</span>
          <span class="badge">${m.element}</span>
          <span class="badge">${m.class}</span>
          <span class="badge">Lv ${m.level}</span>
        </div>
        <div class="statgrid">
          <div class="stat">ATK: <b>${m.stats.atk}</b></div>
          <div class="stat">DEF: <b>${m.stats.def}</b></div>
          <div class="stat">SPD: <b>${m.stats.spd}</b></div>
          <div class="stat">EXP: <b>${m.exp}/${xpNeededFor(m.level)}</b></div>
        </div>
        <div style="margin-top:8px">
          <div style="display:flex;align-items:center;gap:8px"><span style="width:58px">HP</span><div class="bar" style="flex:1"><span class="hp" style="width:${hpPct}%"></span></div></div>
          <div style="height:6px"></div>
          <div style="display:flex;align-items:center;gap:8px"><span style="width:58px">STA</span><div class="bar" style="flex:1"><span class="sta" style="width:${staPct}%"></span></div></div>
        </div>
      </div>
    </div>
    <div style="margin-top:8px;display:flex;gap:8px;flex-wrap:wrap">
      <button data-act="team" data-id="${m.id}">Add to Team</button>
      <button data-act="break" data-id="${m.id}" class="ghost">Break ‚Üí Shards</button>
    </div>
  </div>`;
}
function showMonsterCard(m, scrollIntoView=false){
  $("#resultZone").innerHTML = monsterCardHTML(m);
  $("#resultZone").querySelectorAll("button").forEach(b=>b.addEventListener('click',onMonsterAction));
  if(scrollIntoView) $("#resultZone").scrollIntoView({behavior:"smooth",block:"start"});
}

function renderInventory(){
  $("#invCount").textContent = state.monsters.length;
  const box=$("#inventoryList"); box.innerHTML="";
  state.monsters.forEach(m=>{
    const el=document.createElement('div');
    el.className="slot "+rarityGlow(m.rarity);
    el.innerHTML=`
      <img src="${m.img}" alt="${m.name}" />
      <div class="name">${m.display}</div>
      <div class="rar" style="color:${RARITY_COLOR[m.rarity]}">${m.rarity}</div>
      <div style="display:flex;gap:6px;margin-top:6px">
        <button data-act="view" data-id="${m.id}">View</button>
        <button data-act="team" data-id="${m.id}">Team</button>
        <button data-act="break" data-id="${m.id}" class="ghost">Break</button>
      </div>`;
    box.appendChild(el);
  });
  box.querySelectorAll("button").forEach(b=>b.addEventListener('click', onMonsterAction));
}
function renderTeam(){
  const box=$("#teamSlots"); box.innerHTML="";
  for(let i=0;i<3;i++){
    const m = state.monsters.find(x=>x.id===state.team[i]);
    const el=document.createElement('div'); el.className="slot";
    if(m){
      el.classList.add(rarityGlow(m.rarity));
      el.innerHTML=`
        <img src="${m.img}" />
        <div class="name">${m.display}</div>
        <div class="rar" style="color:${RARITY_COLOR[m.rarity]}">${m.rarity}</div>
        <button data-act="removeTeam" data-id="${m.id}" class="ghost">Remove</button>
      `;
    }else{
      el.innerHTML=`<div style="opacity:.6">Empty</div>`;
    }
    box.appendChild(el);
  }
  box.querySelectorAll("button").forEach(b=>b.addEventListener('click',onMonsterAction));
}
function renderLoot(){
  const box=$("#lootList"); box.innerHTML="";
  const entries = Object.entries(state.loot);
  if(entries.length===0){ box.innerHTML="<div class='pill'>No loot yet</div>"; return; }
  for(const [id,qty] of entries){
    const el=document.createElement('div'); el.className="slot"; el.innerHTML=`<div class="name">${id}</div><div>x${qty}</div>`;
    box.appendChild(el);
  }
  $("#shardCount").textContent = state.loot.shard||0;
  $("#goldCount").textContent  = (state.loot.gold_small||0)+(state.loot.gold_med||0)+(state.loot.gold_big||0);
  $("#matCount").textContent   = (state.loot.mat_wolfFang||0)+(state.loot.mat_dragonScale||0)+(state.loot.mat_krakenEye||0);
}
function renderMythics(){
  const box=$("#mythicList"); box.innerHTML="";
  const mythNames = Object.keys(state.mythicsSeen);
  $("#mythCount").textContent = mythNames.length;
  if(mythNames.length===0){ box.innerHTML="<div class='pill'>No mythics yet</div>"; return; }
  mythNames.forEach(n=>{
    const el=document.createElement('div'); el.className="slot glow-Mythic";
    el.innerHTML=`<div class="name">${n}</div><div class="rar" style="color:${RARITY_COLOR.Mythic}">Mythic</div>`;
    box.appendChild(el);
  });
}
function renderUpgrades(){
  const box=$("#upgradeArea"); box.innerHTML="";
  const wep = state.items.weapon, arm=state.items.armor;

  const itemCard = (t, it) => `
    <div class="monster-card">
      <div style="display:flex;gap:10px;align-items:center">
        <div style="font-weight:800">${t}</div>
        <span class="badge" style="border-color:${RARITY_COLOR[it.rarity]};color:${RARITY_COLOR[it.rarity]}">${it.rarity}</span>
        <span class="badge">Lv ${it.lvl}</span>
      </div>
      <div style="margin-top:8px;display:flex;gap:8px;flex-wrap:wrap">
        <button data-item="${t}" data-act="upgradeItem">Upgrade (+)</button>
        <button data-item="${t}" data-act="ultimateItem" class="ghost">Ultimate (Mythic)</button>
      </div>
      <div style="opacity:.85;margin-top:6px;font-size:.9rem">Upgrades cost shards + gold. Ultimate needs Mythic Core (boss) + level + shards.</div>
    </div>`;
  box.innerHTML = itemCard("Weapon",wep) + itemCard("Armor",arm);
  box.querySelectorAll("button").forEach(b=>b.addEventListener('click', onUpgradeAction));
}

function renderAll(){
  renderInventory(); renderTeam(); renderLoot(); renderMythics(); renderUpgrades();
  $("#killCount").textContent = state.killCount;
}

/* =========================
   ACTION HANDLERS
========================= */
function onMonsterAction(e){
  const act=e.target.dataset.act; const id=e.target.dataset.id;
  const m=state.monsters.find(x=>x.id===id);
  if(act==="view" && m){ showMonsterCard(m,true); }
  if(act==="team" && m){
    if(state.team.includes(id)) return;
    if(state.team.length<3){ state.team.push(id); saveState(); renderTeam(); toast("Added to team"); }
    else toast("Team is full");
  }
  if(act==="removeTeam" && m){
    state.team = state.team.filter(x=>x!==id); saveState(); renderTeam();
  }
  if(act==="break" && m){
    // require level threshold to block breaking fresh mythics if you want (optional)
    const shardsGained = Math.max(1, Math.round((RARITY_MOD[m.rarity]||0)/5));
    addLoot("shard", shardsGained);
    state.monsters = state.monsters.filter(x=>x.id!==id);
    state.team = state.team.filter(x=>x!==id);
    saveState(); renderAll(); toast(`+${shardsGained} shards`);
  }
}

function onUpgradeAction(e){
  const t=e.target.dataset.item; if(!t) return;
  const isUltimate = e.target.dataset.act==="ultimateItem";
  const it = state.items[t.toLowerCase()];
  // Costs
  if(isUltimate){
    const needLvl = 5; // require item lvl 5
    if(it.lvl<needLvl){ toast(`${t} must be Lv ${needLvl} first.`); return; }
    if((state.loot.mythic_core||0)<1){ toast("Need 1 Mythic Core."); return; }
    if((state.loot.shard||0)<5){ toast("Need 5 shards."); return; }
    it.rarity="Mythic"; it.lvl++;
    state.loot.mythic_core--; state.loot.shard-=5;
    toast(`${t} ascended to Mythic!`);
  }else{
    const costShards = Math.max(1, Math.ceil((it.lvl+1)/2));
    if((state.loot.shard||0)<costShards){ toast(`Need ${costShards} shards`); return; }
    state.loot.shard -= costShards; it.lvl++;
    toast(`${t} upgraded to Lv ${it.lvl}`);
  }
  saveState(); renderUpgrades(); renderLoot();
}

/* =========================
   BATTLES
========================= */
function teamPower(){
  return state.team.map(id=>state.monsters.find(m=>m.id===id)).filter(Boolean).reduce((s,m)=>{
    // simple score: atk+def+spd + rarity bonus + item bonuses
    const rb = (RARITY_MOD[m.rarity]||0);
    return s + (m.stats.atk+m.stats.def+m.stats.spd+rb);
  },0) + (state.items.weapon.lvl*5) + (state.items.armor.lvl*5);
}
function randomEncounter(type){ // "wild" | "miniboss" | "boss"
  const pool = {
    wild: { name:["dog","cat","squirrel","spider","fly","ladybug"], hp:[80,120], atk:[35,75], imgKey: null },
    miniboss: { name:["wolf","golem"], hp:[220,300], atk:[70,110], imgKey:"miniboss" },
    boss: { name:["dragon","kraken"], hp:[420,560], atk:[100,150], imgKey:"boss" }
  }[type];

  const pick = pool.name[randInt(0,pool.name.length-1)];
  const img = pool.imgKey==="boss" ? (BOSS_ART[pick]||BOSS_ART.dragon)
           : pool.imgKey==="miniboss" ? (MINIBOSS_ART[pick]||MINIBOSS_ART.wolf)
           : (MONSTER_DEX[pick]?.img || MONSTER_DEX["wild beast"].img);

  return {
    type, name: pick[0].toUpperCase()+pick.slice(1),
    hp: randInt(pool.hp[0], pool.hp[1]),
    atk: randInt(pool.atk[0], pool.atk[1]),
    element: ELEMENTS[randInt(0,ELEMENTS.length-1)],
    img
  };
}
function outcomeChance(youPow, foe){
  let base = 0.55; // make wilds winnable
  if(foe.type==="miniboss") base=0.35;
  if(foe.type==="boss") base=0.12; // ~12% baseline; you asked ~7% or less‚Äîfinal chance also scales below

  // scale by power difference
  const foePow = foe.atk + foe.hp/3;
  const diff = youPow - foePow;
  let mod = diff/600; // soft scaling
  mod = clamp(mod,-0.25,0.25);
  let p = clamp(base + mod, 0.03, (foe.type==="boss"?0.12:0.75));
  return p;
}
function fightNow(type){
  const youPow = teamPower();
  const foe = randomEncounter(type);
  const winP = outcomeChance(youPow,foe);
  const win = Math.random() < winP;

  const area=$("#battleArea");
  area.innerHTML = `
    <div class="monster-card ${type==='boss'?'glow-Mythic': type==='miniboss'?'glow-Legendary':'glow-Rare'}">
      <div class="monster-head">
        <div class="monster-img"><img src="${foe.img}" alt="${foe.name}"/></div>
        <div>
          <div style="font-weight:800">${type.toUpperCase()} ‚Äî ${foe.name}</div>
          <div class="statgrid">
            <div class="stat">Element: <b>${foe.element}</b></div>
            <div class="stat">HP: <b>${foe.hp}</b></div>
            <div class="stat">ATK: <b>${foe.atk}</b></div>
            <div class="stat">Your Team Power: <b>${youPow}</b></div>
            <div class="stat">Win Chance: <b>${Math.round(winP*100)}%</b></div>
          </div>
        </div>
      </div>
      <div style="margin-top:8px">
        <div style="font-weight:700">${win? "Victory! üéâ":"Defeat üòµ"}</div>
        <div id="lootRow" class="row" style="margin-top:8px"></div>
      </div>
    </div>`;

  if(win){
    state.killCount++; $("#killCount").textContent=state.killCount;
    // Reward EXP to team
    const expGain = (type==="boss"? 60 : type==="miniboss"? 35 : 18);
    for(const id of state.team){
      const m = state.monsters.find(x=>x.id===id); if(!m) continue;
      m.exp += expGain;
      while(m.exp >= xpNeededFor(m.level)){
        m.exp -= xpNeededFor(m.level);
        m.level++;
        // small stat bumps on level
        m.stats.hp += 4; m.stats.sta += 3; m.stats.atk += 2; m.stats.def += 2; m.stats.spd += 2;
      }
    }
    saveState(); renderTeam(); renderInventory();

    // Drops
    const table = LOOT_TABLE[type];
    const drops=[];
    for(const entry of table){
      if(Math.random() < entry.chance){
        const qty = Array.isArray(entry.qty)? randInt(entry.qty[0], entry.qty[1]) : entry.qty;
        drops.push({id:entry.id, name:entry.name, qty, rarity:entry.rarity});
        state.loot[entry.id]=(state.loot[entry.id]||0)+qty;
        // Track mythic discovery
        if(entry.id==="mythic_core"||entry.id==="ultra_mythic_spark"){
          cinematicReveal(entry);
        }
      }
    }
    saveState(); renderLoot();
    showDrops(drops);
  }else{
    toast("You retreated to recover‚Ä¶");
  }
}

function showDrops(drops){
  const row=$("#lootRow");
  row.innerHTML="";
  if(drops.length===0){ row.innerHTML="<div class='pill'>No loot</div>"; return; }
  drops.forEach(d=>{
    const el=document.createElement('div');
    el.className="pill";
    el.style.borderColor="#444";
    el.style.background="#1e1e1e";
    el.textContent = `${d.name} x${d.qty}`;
    row.appendChild(el);

    // fly to inventory animation
    const img=document.createElement('div');
    img.className="loot-fly";
    img.textContent="üì¶";
    img.style.left="50%"; img.style.bottom="120px";
    document.body.appendChild(img);
    setTimeout(()=>{ img.style.transform="translate(360px,-420px) scale(0.6)"; img.style.opacity="0"; },10);
    setTimeout(()=>img.remove(),900);
  });
  toast("Loot sent to Inventory");
}

function cinematicReveal(entry){
  const modal=$("#cinematic");
  $("#cinTitle").textContent = entry.id==="ultra_mythic_spark" ? "ULTRA-MYTHIC CHANCE!" : "MYTHIC DISCOVERED!";
  $("#cinImg").src = BOSS_ART.dragon; // generic icon; swap to a mythic emblem later
  $("#cinImg").classList.add("silhouette");
  $("#cinText").innerHTML = `
    <div style="color:${RARITY_COLOR.Mythic};font-weight:800;margin-bottom:6px">${entry.name}</div>
    <div>You found a ${entry.name}. Combine this with shards and levels to unlock an Ultimate upgrade!</div>
  `;
  modal.classList.add("show");
}

/* =========================
   TABS & EVENTS
========================= */
function switchTab(tab){
  $$(".tab").forEach(t=>t.classList.toggle("active", t.dataset.tab===tab));
  ["inventory","team","battle","upgrades","loot","mythic"].forEach(id=>{
    $("#panel-"+id).style.display = (id===tab) ? "block" : "none";
  });
}
$$(".tab").forEach(t=>t.addEventListener('click', ()=>switchTab(t.dataset.tab)));
$("#cinClose").addEventListener('click', ()=> $("#cinematic").classList.remove('show'));

// Buttons
$("#btnStartCam").addEventListener('click', startCamera);
$("#btnStopCam").addEventListener('click', stopCamera);
$("#btnCapture").addEventListener('click', captureFromVideo);
$("#btnUpload").addEventListener('click', ()=>$("#fileInput").click());
$("#fileInput").addEventListener('change', e=>{
  const f=e.target.files?.[0]; if(f) captureFromFile(f);
});

// Battle buttons
$("#btnWild").addEventListener('click', ()=>fightNow("wild"));
$("#btnMiniBoss").addEventListener('click', ()=>fightNow("miniboss"));
$("#btnBoss").addEventListener('click',  ()=>fightNow("boss"));

/* =========================
   INIT
========================= */
(async function boot(){
  try{ await loadModel(); }catch(e){ console.error("Model load failed:",e); }
  renderAll();
})();
</script>
</body>
</html>  }
  .btn.secondary{ background:#2d3640; color:#d6e7ff }
  .btn.warn{ background:var(--warn); color:#1b1302 }
  .btn.danger{ background:var(--danger) }
  .btn.ok{ background:var(--ok); color:#02140a }
  .btn:disabled{opacity:.5; cursor:not-allowed}

  .camShell{position:relative; background:#000; border-radius:12px; overflow:hidden; border:2px solid #39424c}
  video, canvas{width:100%; height:auto; display:block; background:#000}
  .devicePick{width:100%; background:#1f2730; color:var(--ink); border:1px solid #303a45; border-radius:10px; padding:10px}

  .log{white-space:pre-wrap; background:#0f0f0f; border:1px solid #2a2a2a; color:#c6d1e5; padding:8px; border-radius:10px; min-height:60px; text-align:left}
  .chip{display:inline-block; background:var(--chip); padding:4px 8px; border-radius:999px; font-size:12px; opacity:.9}

  .collection{display:grid; grid-template-columns:1fr; gap:10px}
  .kpi{display:flex; gap:8px; align-items:center; padding:8px 10px}
  .kpi .pill{background:#212a33; border:1px solid #2e3743; border-radius:999px; padding:6px 10px}

  .monsterGrid{display:grid; grid-template-columns:repeat(2,1fr); gap:10px}
  @media (max-width:540px){ .monsterGrid{grid-template-columns:1fr} }

  .mCard{background:#13181d; border:1px solid #29313a; border-radius:12px; overflow:hidden}
  .mCard img{width:100%; display:block; aspect-ratio:16/10; object-fit:cover; background:#0b0b0b}
  .mBody{padding:10px}
  .mTop{display:flex; align-items:center; justify-content:space-between; gap:10px}
  .mName{font-weight:800; letter-spacing:.3px}
  .rar{font-size:12px; padding:2px 8px; border-radius:999px; border:1px solid #2d3440}
  .rar.common{background:#1f2630; color:#b7c0d4}
  .rar.uncommon{background:#173126; color:#a8e6c3; border-color:#285a43}
  .rar.rare{background:#2a1837; color:#e7befc; border-color:#6741a0}
  .stats{display:grid; grid-template-columns:repeat(2,1fr); gap:6px; margin-top:8px}
  .stat{background:#101419; border:1px solid #222a33; padding:6px 8px; border-radius:8px; font-size:13px}
  .actions{display:flex; gap:8px; margin-top:8px}
  .teamRow{display:grid; grid-template-columns:repeat(3,1fr); gap:10px}
  .slot{min-height:84px; border:1px dashed #3a3a3a; border-radius:12px; display:grid; place-items:center; background:#0f1419}
  .slot .hint{opacity:.7; font-size:12px}

  .modalMask{position:fixed; inset:0; background:rgba(0,0,0,.6); display:none; place-items:center; z-index:50}
  .modal{background:var(--panel); border:1px solid #2c363f; border-radius:12px; max-width:520px; width:92%; padding:12px}
  .modal h3{margin:8px 0 6px}
</style>
</head>
<body>
  <header>
    <h1>Monster Transform Game</h1>
    <p>Capture a real creature and see its monster form. Works on desktop, Android, and iPhone (HTTPS).</p>
  </header>

  <main class="wrap">
    <!-- LEFT: Capture / Upload -->
    <section class="card">
      <div class="head">Capture</div>
      <div class="pad">
        <div id="status" class="chip">Initializing‚Ä¶</div>
        <div class="camShell" style="margin-top:10px;">
          <video id="webcam" playsinline muted></video>
          <canvas id="frame" hidden></canvas>
        </div>

        <div class="row" style="margin-top:10px;">
          <button id="btnEnable" class="btn">üé• Enable Camera</button>
          <button id="btnCapture" class="btn secondary" disabled>üì∏ Capture Photo</button>
          <label class="btn secondary">
            ‚¨ÜÔ∏è Upload Photo
            <input id="uploader" type="file" accept="image/*" hidden>
          </label>
          <select id="deviceSel" class="devicePick"></select>
        </div>

        <div id="log" class="log" style="margin-top:10px;">Log: ready.</div>
      </div>
    </section>

    <!-- RIGHT: Collection / Team -->
    <section class="card">
      <div class="head">Your Collection</div>
      <div class="pad collection">
        <div class="kpi">
          <div class="pill">Upgrade Dust: <span id="dust">0</span></div>
          <div class="pill">Team: <span id="teamCount">0</span>/3</div>
          <div class="pill">Inventory: <span id="invCount">0</span>/20</div>
        </div>

        <h3>Team</h3>
        <div id="team" class="teamRow"></div>

        <h3 style="margin-top:10px;">Inventory</h3>
        <div id="inventory" class="monsterGrid"></div>

        <div class="row" style="margin-top:12px;">
          <button id="btnWild" class="btn">‚öîÔ∏è Wild Battle</button>
          <button id="btnBoss" class="btn warn">üëπ Boss Hunt</button>
          <span class="chip">Battles auto-resolve for now.</span>
        </div>
      </div>
    </section>
  </main>

  <!-- Force-breakdown modal -->
  <div id="modalMask" class="modalMask">
    <div class="modal">
      <h3>Inventory Full</h3>
      <p>You can store up to 20 monsters. Pick one to <strong>break down</strong> into shards to make room.</p>
      <div id="modalList" class="monsterGrid" style="max-height:50vh; overflow:auto;"></div>
      <div class="row" style="margin-top:10px; justify-content:flex-end;">
        <button id="modalCancel" class="btn secondary">Cancel</button>
      </div>
    </div>
  </div>

<script>
/* -----------------------------
   CONFIG / CONSTANTS
------------------------------*/
const MODEL_URL = "model_real/"; // model.json, metadata.json, weights.bin in this folder

// Optional: when you add a second model (e.g., bird) you can switch by changing this:
// const MODEL_URL = "models/bird/";

// Map model className -> digital artwork (in /digital_images/)
const DIGITAL_ART = {
  ladybug: "digital_images/ladybug.jpeg",
  squirrel:"digital_images/squirrel.jpeg",
  dog:     "digital_images/dog.jpeg",
  cat:     "digital_images/cat.jpeg",
  spider:  "digital_images/spider.jpeg",
  fly:     "digital_images/fly.jpeg",
  // add more here as you create art: "bird":"digital_images/bird.jpeg"
};

// Base stat templates by archetype (then adjusted by rarity + small randomness)
const ARCHETYPES = {
  // {hp, atk, def, spd, crit, element, class}
  ladybug: { hp:90,  atk:40, def:90, spd:35, crit:8,  element:"Light",  class:"Guardian" },
  squirrel:{ hp:70,  atk:55, def:60, spd:90, crit:16, element:"Nature", class:"Skirmisher"},
  dog:     { hp:85,  atk:60, def:75, spd:55, crit:10, element:"Earth",  class:"Guardian" },
  cat:     { hp:65,  atk:88, def:45, spd:92, crit:18, element:"Shadow", class:"Assassin" },
  spider:  { hp:72,  atk:55, def:68, spd:60, crit:12, element:"Poison", class:"Trapper" },
  fly:     { hp:50,  atk:40, def:35, spd:99, crit:14, element:"Air",    class:"Scout"  },
  // you can add others matching your model classes later
};

// Battle pool (wild + bosses). Bosses are very hard.
const WILD_POOL = [
  { name:"wild-cat",     base:{hp:70, atk:60, def:45, spd:70, crit:10}, element:"Shadow", class:"Skirmisher" },
  { name:"wild-dog",     base:{hp:85, atk:60, def:70, spd:55, crit: 9}, element:"Earth",  class:"Guardian"  },
  { name:"wild-ladybug", base:{hp:90, atk:40, def:90, spd:35, crit: 8}, element:"Light",  class:"Guardian"  },
  { name:"wild-spider",  base:{hp:75, atk:52, def:70, spd:62, crit:11}, element:"Poison", class:"Trapper"   },
  { name:"wild-squirrel",base:{hp:68, atk:58, def:60, spd:88, crit:15}, element:"Nature", class:"Skirmisher"},
  { name:"wild-fly",     base:{hp:50, atk:40, def:35, spd:95, crit:14}, element:"Air",    class:"Scout"     },
];
const BOSS_POOL = [
  { name:"Boss Tiger",      boss:true, base:{hp:320, atk:95,  def:80,  spd:85,  crit:16}, element:"Savanna", class:"Predator" },
  { name:"Boss Bear",       boss:true, base:{hp:420, atk:85,  def:110, spd:55,  crit:10}, element:"Earth",   class:"Juggernaut" },
  { name:"Boss Shark",      boss:true, base:{hp:360, atk:100, def:85,  spd:80,  crit:18}, element:"Water",   class:"Ravager" },
  { name:"Boss Lion",       boss:true, base:{hp:340, atk:98,  def:88,  spd:82,  crit:17}, element:"Savanna", class:"Predator" },
  { name:"Boss Snake",      boss:true, base:{hp:300, atk:88,  def:70,  spd:90,  crit:22}, element:"Poison",  class:"Ambusher" },
  { name:"Boss Alligator",  boss:true, base:{hp:380, atk:92,  def:105, spd:60,  crit:12}, element:"Water",   class:"Guardian" },
  { name:"Boss Pelican",    boss:true, base:{hp:360, atk:84,  def:80,  spd:88,  crit:14}, element:"Air",     class:"Overlord" }
];

// Rarity chances and multipliers
const RARITY_TABLE = [
  { key:"rare",      chance: 0.01, mult: 1.18 }, // ~1%, noticeably stronger
  { key:"uncommon",  chance: 0.15, mult: 1.12 }, // 15%
  { key:"common",    chance: 0.84, mult: 1.00 }, // rest
];

// inventory limits
const INV_LIMIT = 20;
const TEAM_LIMIT = 3;

/* -----------------------------
   STATE / STORAGE
------------------------------*/
const S = {
  monsters: [], // inventory
  team: [],     // array of monster ids
  dust: 0,
  nextId: 1,
};
const LS_KEY = "lenslair_save_v2";

function loadState(){
  try{
    const raw = localStorage.getItem(LS_KEY);
    if(raw){
      const obj = JSON.parse(raw);
      Object.assign(S, obj);
    }
  }catch(e){ console.warn("Load state error:", e); }
}
function saveState(){
  localStorage.setItem(LS_KEY, JSON.stringify(S));
}
function wipeState(){
  localStorage.removeItem(LS_KEY);
  location.reload();
}

/* -----------------------------
   UTIL
------------------------------*/
function log(msg){ const el = document.getElementById("log"); el.textContent = (el.textContent + "\n" + msg).slice(-2000); }
function byId(id){ return document.getElementById(id); }
function randInt(min,max){ return Math.floor(Math.random()*(max-min+1))+min; }
function pickRarity(){
  let r = Math.random();
  let acc = 0;
  for(const row of RARITY_TABLE){
    acc += row.chance;
    if(r <= acc) return row;
  }
  return RARITY_TABLE[RARITY_TABLE.length-1];
}
function statRoll(base, mult){
  // slight randomization around the multiplier (¬±4%)
  const jitter = 1 + (Math.random()*0.08 - 0.04);
  return Math.max(1, Math.round(base * mult * jitter));
}
function imgOrPlaceholder(name){
  const src = DIGITAL_ART[name?.toLowerCase()];
  return src || "https://dummyimage.com/640x360/0a0a0a/ffffff&text=Monster";
}

/* -----------------------------
   CAMERA / MODEL
------------------------------*/
let model = null, metadata = null;
let stream = null;
const video = byId("webcam");
const canvas = byId("frame");
const deviceSel = byId("deviceSel");
const statusChip = byId("status");

async function loadModel(){
  try{
    model = await tmImage.load(MODEL_URL + "model.json", MODEL_URL + "metadata.json");
    metadata = model?.getTotalClasses?.() ?? null;
    log("‚úÖ Model loaded");
    statusChip.textContent = "Model ready.";
  }catch(e){
    log("‚ö†Ô∏è Model load failed ‚Äî capturing will still create a monster via fallback. " + e.message);
    statusChip.textContent = "Model unavailable (fallback active)";
  }
}

// enumerate devices for camera selection (helps iOS/Android)
async function refreshDevices(){
  try{
    const list = await navigator.mediaDevices.enumerateDevices();
    const cams = list.filter(d => d.kind === "videoinput");
    deviceSel.innerHTML = "";
    cams.forEach((d, i)=>{
      const o = document.createElement("option");
      o.value = d.deviceId;
      o.textContent = d.label || `Camera ${i+1}`;
      deviceSel.appendChild(o);
    });
    if(cams.length===0){
      const o = document.createElement("option");
      o.value = "";
      o.textContent = "No camera found";
      deviceSel.appendChild(o);
    }
  }catch(e){ log("enumerateDevices error: " + e.message); }
}

async function startCamera(deviceId){
  if(stream){ stream.getTracks().forEach(t=>t.stop()); stream=null; }
  const constraints = deviceId
    ? { video: { deviceId: { exact: deviceId } } }
    : { video: { facingMode: { ideal:"environment" } } };

  try{
    stream = await navigator.mediaDevices.getUserMedia(constraints);
    video.srcObject = stream;
    await video.play();
    statusChip.textContent = "Camera ready.";
    byId("btnCapture").disabled = false;
    log("üé• Camera started");
  }catch(e){
    log("Camera error: " + e.name + " ‚Äî " + e.message);
    statusChip.textContent = "Camera failed. Try a different device above or use Upload.";
    byId("btnCapture").disabled = true;
  }
}

function drawCurrentFrame(){
  const w = video.videoWidth || 640, h = video.videoHeight || 480;
  canvas.width = w; canvas.height = h;
  const ctx = canvas.getContext("2d");
  ctx.drawImage(video, 0, 0, w, h);
  return canvas;
}

/* -----------------------------
   MONSTER CREATION
------------------------------*/
function createFromClassName(cls){
  // base from archetype (or generic if unknown)
  const key = (cls||"").toLowerCase();
  const base = ARCHETYPES[key] || { hp:70, atk:60, def:60, spd:60, crit:10, element:"Neutral", class:"Adventurer" };
  const art = imgOrPlaceholder(key);

  const rarityRow = pickRarity(); // rare/uncommon/common
  const mult = rarityRow.mult;

  const monster = {
    id: S.nextId++,
    name: key || "unknown",
    element: base.element,
    class: base.class,
    rarity: rarityRow.key,
    art,
    // rolled stats
    hp:  statRoll(base.hp,  mult),
    atk: statRoll(base.atk, mult),
    def: statRoll(base.def, mult),
    spd: statRoll(base.spd, mult),
    crit:statRoll(base.crit,mult),
    lvl:1, xp:0,
    ts: Date.now()
  };
  return monster;
}

async function classifyCanvas(canv){
  if(!model){
    log("Model not loaded, using fallback class.");
    return null;
  }
  const preds = await model.predict(canv);
  preds.sort((a,b)=>b.probability-a.probability);
  const top = preds[0];
  if(!top || top.probability < 0.40){
    log("Low confidence ("+(top?.probability?.toFixed(2)??"n/a")+") ‚Äî using fallback.");
    return null;
  }
  return (top.className||"").toLowerCase();
}

async function pipelineFromCanvas(canv){
  // classify ‚Üí build monster ‚Üí enforce capacity ‚Üí render/save
  let cls = null;
  try{ cls = await classifyCanvas(canv); }
  catch(e){ log("Prediction failed: " + e.message); }

  const monster = createFromClassName(cls);
  await ensureCapacityOrBreakdown(); // may open modal
  S.monsters.push(monster);
  saveState();
  renderAll();
  log(`‚ú® Created ${monster.rarity.toUpperCase()} ${monster.name.toUpperCase()} (HP:${monster.hp} ATK:${monster.atk})`);
}

/* -----------------------------
   INVENTORY CAP / BREAKDOWN
------------------------------*/
const mask = byId("modalMask"), modalList = byId("modalList"), modalCancel = byId("modalCancel");
modalCancel.addEventListener("click", ()=> mask.style.display="none");

async function ensureCapacityOrBreakdown(){
  if(S.monsters.length < INV_LIMIT) return;
  // Force user to break one down
  return new Promise(resolve=>{
    modalList.innerHTML = "";
    S.monsters.forEach(m=>{
      const card = miniCard(m, [
        {label:"Break for Shards", cls:"danger", onClick:()=>{
          const shards = m.rarity==="rare" ? 40 : m.rarity==="uncommon" ? 18 : 8;
          S.dust += shards;
          // also drop from team if present
          S.team = S.team.filter(id=>id!==m.id);
          S.monsters = S.monsters.filter(x=>x.id!==m.id);
          saveState(); renderAll();
          resolve();
          mask.style.display="none";
        }}
      ]);
      modalList.appendChild(card);
    });
    mask.style.display="grid";
  });
}

/* -----------------------------
   RENDERING
------------------------------*/
function monsterCard(mon, ctx="inventory"){
  const el = document.createElement("div");
  el.className = "mCard";
  el.innerHTML = `
    <img src="${mon.art}" alt="${mon.name}">
    <div class="mBody">
      <div class="mTop">
        <div class="mName">${mon.name.toUpperCase()} ‚Ä¢ <span style="opacity:.8">${mon.element}</span></div>
        <div class="rar ${mon.rarity}">${mon.rarity}</div>
      </div>
      <div class="stats">
        <div class="stat">HP: <b>${mon.hp}</b></div>
        <div class="stat">ATK: <b>${mon.atk}</b></div>
        <div class="stat">DEF: <b>${mon.def}</b></div>
        <div class="stat">SPD: <b>${mon.spd}</b></div>
        <div class="stat">CRIT: <b>${mon.crit}%</b></div>
        <div class="stat">LVL: <b>${mon.lvl}</b></div>
      </div>
      <div class="actions"></div>
    </div>`;
  const acts = el.querySelector(".actions");

  if(ctx==="inventory"){
    // add to team (if there is space)
    const b1 = button("Add to Team", "ok", ()=>{
      if(S.team.includes(mon.id)) return;
      if(S.team.length >= TEAM_LIMIT){ alert("Team is full (3). Remove one first."); return; }
      S.team.push(mon.id); saveState(); renderAll();
    });
    const b2 = button("Breakdown", "danger", ()=>{
      const shards = mon.rarity==="rare" ? 40 : mon.rarity==="uncommon" ? 18 : 8;
      if(!confirm(`Break ${mon.name.toUpperCase()} for ${shards} shards?`)) return;
      S.dust += shards;
      S.monsters = S.monsters.filter(x=>x.id!==mon.id);
      S.team = S.team.filter(id=>id!==mon.id);
      saveState(); renderAll();
    });
    acts.append(b1,b2);
  }else if(ctx==="team"){
    const b1 = button("Remove", "secondary", ()=>{
      S.team = S.team.filter(id=>id!==mon.id);
      saveState(); renderAll();
    });
    acts.append(b1);
  }
  return el;
}
function miniCard(mon, actions=[]){
  const el = document.createElement("div");
  el.className = "mCard";
  el.innerHTML = `
    <img src="${mon.art}" alt="${mon.name}">
    <div class="mBody">
      <div class="mTop"><div class="mName">${mon.name.toUpperCase()}</div><div class="rar ${mon.rarity}">${mon.rarity}</div></div>
      <div class="stats">
        <div class="stat">HP:${mon.hp}</div>
        <div class="stat">ATK:${mon.atk}</div>
      </div>
      <div class="actions"></div>
    </div>`;
  const acts = el.querySelector(".actions");
  actions.forEach(a=>{
    const b = button(a.label, a.cls, a.onClick); acts.appendChild(b);
  });
  return el;
}
function button(txt, cls, onClick){
  const b = document.createElement("button");
  b.className = "btn " + (cls||"");
  b.textContent = txt;
  b.addEventListener("click", onClick);
  return b;
}

function renderAll(){
  byId("dust").textContent = S.dust;
  byId("invCount").textContent = S.monsters.length;
  byId("teamCount").textContent = S.team.length;

  // team view
  const teamEl = byId("team");
  teamEl.innerHTML = "";
  for(let i=0;i<TEAM_LIMIT;i++){
    const id = S.team[i];
    if(id){
      const mon = S.monsters.find(x=>x.id===id);
      if(mon) teamEl.appendChild(monsterCard(mon,"team"));
      else{
        // clean up dangling ids
        S.team = S.team.filter(tid => S.monsters.some(m=>m.id===tid));
        saveState();
      }
    }else{
      const slot = document.createElement("div");
      slot.className = "slot";
      slot.innerHTML = `<div class="hint">Empty slot</div>`;
      teamEl.appendChild(slot);
    }
  }
  // inventory
  const invEl = byId("inventory");
  invEl.innerHTML = "";
  S.monsters
    .filter(m => !S.team.includes(m.id))
    .sort((a,b)=>b.ts-a.ts)
    .forEach(m=> invEl.appendChild(monsterCard(m,"inventory")));
}

/* -----------------------------
   BATTLES (auto-resolve)
------------------------------*/
function basicDuel(a, b){
  // very quick auto resolution: each turn, damage = atk * (100/(100+def)) * variance
  function dmg(att, def){
    const raw = att * (100/(100 + def));
    const variance = 0.85 + Math.random()*0.3;
    let crit = 1;
    if(Math.random() < (att.crit||10)/100) crit = 1.5;
    return Math.max(1, Math.round(raw * variance * crit));
  }
  let ahp=a.hp, bhp=b.hp;
  let turns=0;
  while(ahp>0 && bhp>0 && turns<200){
    // initiative: higher spd first; tie random
    const first = (a.spd===b.spd) ? (Math.random()<0.5?a:b) : ((a.spd>b.spd)?a:b);
    const second = (first===a)?b:a;
    if(first===a){ bhp -= dmg(a,b); if(bhp<=0) break; ahp -= dmg(b,a); }
    else        { ahp -= dmg(b,a); if(ahp<=0) break; bhp -= dmg(a,b); }
    turns++;
  }
  return ahp>0 ? "player" : "enemy";
}

function pickWild(boss=false){
  const src = boss ? BOSS_POOL : WILD_POOL;
  const x = src[Math.floor(Math.random()*src.length)];
  return {
    name: x.name,
    element: x.element,
    class: x.class,
    rarity: boss ? "boss" : "wild",
    art: imgOrPlaceholder(x.name.includes("wild-") ? x.name.split("wild-")[1] : x.name),
    ...x.base
  };
}

function runBattle(boss=false){
  if(S.team.length===0){ alert("Add at least one monster to your team first."); return; }

  // build combined team power (sum of top 3)
  const teamMons = S.team.map(id => S.monsters.find(m=>m.id===id)).filter(Boolean);
  const teamFighter = {
    name:"Your Team",
    hp: teamMons.reduce((s,m)=>s+m.hp,0),
    atk:Math.round(teamMons.reduce((s,m)=>s+m.atk,0)/teamMons.length),
    def:Math.round(teamMons.reduce((s,m)=>s+m.def,0)/teamMons.length),
    spd:Math.round(teamMons.reduce((s,m)=>s+m.spd,0)/teamMons.length),
    crit:Math.round(teamMons.reduce((s,m)=>s+m.crit,0)/teamMons.length),
  };

  // enemy
  const enemy = pickWild(boss);

  const who = basicDuel(teamFighter, enemy);
  if(who==="player"){
    const reward = boss ? 120 : 25 + Math.round(Math.random()*20);
    S.dust += reward;
    saveState(); renderAll();
    alert(`Victory!\nYou defeated ${enemy.name} and gained ${reward} dust.`);
  }else{
    alert(`Defeat‚Ä¶ ${enemy.name} was too strong this time.`);
  }
}

/* -----------------------------
   EVENT WIRING
------------------------------*/
byId("btnEnable").addEventListener("click", async ()=>{
  if(location.protocol!=="https:"){
    alert("On mobile Safari/Chrome, camera requires HTTPS (GitHub Pages is fine). Upload still works.");
  }
  await refreshDevices();
  const id = deviceSel.value || undefined;
  await startCamera(id);
});

deviceSel.addEventListener("change", async (e)=>{ await startCamera(e.target.value); });

byId("btnCapture").addEventListener("click", async ()=>{
  try{
    const canv = drawCurrentFrame();
    await pipelineFromCanvas(canv);
  }catch(e){
    log("Capture flow error: " + e.message);
  }
});

byId("uploader").addEventListener("change", async (e)=>{
  const file = e.target.files?.[0];
  if(!file) return;
  try{
    const img = new Image();
    img.onload = async ()=>{
      canvas.width = img.naturalWidth; canvas.height = img.naturalHeight;
      const ctx = canvas.getContext("2d");
      ctx.drawImage(img, 0, 0);
      await pipelineFromCanvas(canvas);
    };
    img.src = URL.createObjectURL(file);
  }catch(err){
    log("Upload flow error: " + err.message);
  }finally{
    e.target.value = "";
  }
});

byId("btnWild").addEventListener("click", ()=> runBattle(false));
byId("btnBoss").addEventListener("click", ()=> runBattle(true));

/* -----------------------------
   BOOT
------------------------------*/
(async function boot(){
  loadState();
  renderAll();
  statusChip.textContent = "Loading model‚Ä¶";
  await loadModel();
  await refreshDevices();
  log("Tip: If camera fails on mobile, pick a different device from the dropdown, or use Upload.");
})();
</script>
</body>
</html>



